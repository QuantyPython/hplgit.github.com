<!--
Automatically generated HTML file from DocOnce source
(https://github.com/hplgit/doconce/)
-->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="DocOnce: https://github.com/hplgit/doconce/" />
<meta name="description" content="Quick Intro to Git and Project Hosting Services">
<meta name="keywords" content="GitHub,gh-pages on GitHub,merging files,merge a single file,forking (a repo),pull request">

<title>Quick Intro to Git and Project Hosting Services</title>


<link href="https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_styles/style_solarized_box/css/solarized_light_code.css" rel="stylesheet" type="text/css" title="light"/>
<script src="https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_styles/style_solarized_box/js/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>

<link href="http://thomasf.github.io/solarized-css/solarized-light.min.css" rel="stylesheet">
<style type="text/css">
h1 {color: #b58900;}  /* yellow */
/* h1 {color: #cb4b16;}  orange */
/* h1 {color: #d33682;}  magenta, the original choice of thomasf */
code { padding: 0px; background-color: inherit; }
pre {
  border: 0pt solid #93a1a1;
  box-shadow: none;
}
.alert-text-small   { font-size: 80%;  }
.alert-text-large   { font-size: 130%; }
.alert-text-normal  { font-size: 90%;  }
.alert {
  padding:8px 35px 8px 14px; margin-bottom:18px;
  text-shadow:0 1px 0 rgba(255,255,255,0.5);
  border:1px solid #93a1a1;
  border-radius: 4px;
  -webkit-border-radius: 4px;
  -moz-border-radius: 4px;
  color: #555;
  background-color: #eee8d5;
  background-position: 10px 5px;
  background-repeat: no-repeat;
  background-size: 38px;
  padding-left: 55px;
  width: 75%;
 }
.alert-block {padding-top:14px; padding-bottom:14px}
.alert-block > p, .alert-block > ul {margin-bottom:1em}
.alert li {margin-top: 1em}
.alert-block p+p {margin-top:5px}
.alert-notice { background-image: url(https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_images/small_yellow_notice.png); }
.alert-summary  { background-image:url(https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_images/small_yellow_summary.png); }
.alert-warning { background-image: url(https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_images/small_yellow_warning.png); }
.alert-question {background-image:url(https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_images/small_yellow_question.png); }

div { text-align: justify; text-justify: inter-word; }
</style>


</head>

<!-- tocinfo
{'highest level': 1,
 'sections': [('Motivation', 1, None, '___sec0'),
              ('Why not Dropbox or Google Drive?', 2, None, '___sec1'),
              ('Repositories and local copies', 2, None, '___sec2'),
              ('Installing Git', 2, None, '___sec3'),
              ('Configuring Git',
               2,
               'bitgit:git:config',
               'bitgit:git:config'),
              ('GitHub', 1, 'bitgit:github', 'bitgit:github'),
              ('Creating a new project', 2, None, '___sec6'),
              ('Collaborating', 3, None, '___sec7'),
              ('Wiki pages', 2, None, '___sec8'),
              ('Project web pages', 2, None, '___sec9'),
              ('User web pages', 2, None, '___sec10'),
              ('Using Git', 1, 'bitgit:git', 'bitgit:git'),
              ('Basic Git commands', 2, None, '___sec12'),
              ('Cloning', 3, None, '___sec13'),
              ('The pull-change-push cycle', 3, None, '___sec14'),
              ('Viewing the history of files', 3, None, '___sec15'),
              ('Retrieving old files', 3, None, '___sec16'),
              ('Reset the entire repo to an old version',
               3,
               None,
               '___sec17'),
              ('Going back to a previous commit', 3, None, '___sec18'),
              ('Merging files with Git',
               2,
               'bitgit:git:merge',
               'bitgit:git:merge'),
              ('Git working style with branching and stashing',
               2,
               'bitgit:git:branch:stash',
               'bitgit:git:branch:stash'),
              ('Branching', 3, None, '___sec21'),
              ('Stashing', 3, None, '___sec22'),
              ('Replacing pull by fetch and merge',
               2,
               'bitgit:git:fetch',
               'bitgit:git:fetch'),
              ('Configuring the `git diff` command', 3, None, '___sec24'),
              ('Team work with forking and pull requests',
               2,
               'bitgit:git:team',
               'bitgit:git:team'),
              ('Cloning a repo with multiple branches',
               2,
               'bitgit:git:clone:branches',
               'bitgit:git:clone:branches'),
              ('Git workflows', 2, None, '___sec27'),
              ('Git tips', 2, None, '___sec28'),
              ('How can I see which files are tracked by Git?',
               3,
               None,
               '___sec29'),
              ('How can I reduce the size of a repo?', 3, None, '___sec30'),
              ('How can I restore missing files?', 3, None, '___sec31'),
              ('More documentation on Git', 2, None, '___sec32'),
              ('Appendix: Working with multiple GitHub accounts',
               1,
               'appendix:github:multiple:accounts',
               'appendix:github:multiple:accounts')]}
end of tocinfo -->

<body>

    
<!-- ------------------- main content ---------------------- -->



<center><h1>Quick Intro to Git and Project Hosting Services</h1></center>  <!-- document title -->

<p>
<!-- author(s): Hans Petter Langtangen -->

<center>
<b>Hans Petter Langtangen</b> [1, 2]
</center>

<p>
<!-- institution(s) -->

<center>[1] <b>Center for Biomedical Computing, Simula Research Laboratory</b></center>
<center>[2] <b>Deptartment of Informatics, University of Oslo</b></center>
<br>
<p>
<center><h4>Oct 4, 2015</h4></center> <!-- date -->
<br>
<p>
<div id="bitgit:top"></div>

<p>
Version control systems allow you to record the history of files and
share files among several computers and collaborators in a
professional way. Especially when working with software development or
technical writing, it is essential to have file changes documented and
to ensure that every computer and person involved in the project have
the most recent updates of the files.

<p>
Projects that you want to share among several computers or project
workers are most conveniently stored at some web site "in the
cloud", here called <em>project hosting services</em>. For efficient access
to the files, and the possibility to work offline, you interact with
local copies of the files on your computers.
I strongly recommend you to use such sites and version control for <em>all</em>
serious programming and scientific writing work.

<p>
<div class="alert alert-block alert-notice alert-text-normal">
<b>Essence.</b>
<p>
The essence of project hosting services is that you have the files
associated with a project in the cloud. Many people may share these
files.  Every time you want to work on the project you explicitly
update your version of the files, edit the files as you like, and
synchronize the files with the "master version" in the cloud.
It is a trivial operation to go back to a previous
version of a file, corresponding to a certain point of time or
labeled with a comment.
You can also use tools to see
what various people have done with the files throughout the history
of the project.
</div>


<p>
<!-- !split -->

<h1 id="___sec0">Motivation </h1>

<p>
Greg Wilson's excellent <a href="http://software-carpentry.org/2010/07/script-for-introduction-to-version-control/" target="_self">Script for Introduction to Version Control</a> provides a detailed motivation why you will benefit greatly
from using version control systems. Here follows a shorter motivation
and a quick overview of the basic concepts.

<h2 id="___sec1">Why not Dropbox or Google Drive? </h2>

<p>
The simplest services for hosting project files are <a href="http://dropbox.com" target="_self">Dropbox</a> and <a href="http://drive.google.com" target="_self">Google Drive</a>.
It is very easy to get started with these systems, and they allow you
to share files among laptops and mobile units with as many users as
you want. The systems offer a kind of version control in that the
files are stored frequently (several times per minute), and you can go
back to previous versions for the last 30 days. However, it is
challenging  to find the right version from the past when there are
so many of them and when the different versions are not annotated with
sensible comments. Another deficiency of Dropbox and Google Drive is
that they sync all your files in a folder, a feature you clearly do not
want if there are many large files (simulation data, visualizations,
movies, binaries from compilations,
temporary scratch files, automatically generated copies)
that can easily be regenerated.

<p>
However, the most serious problem with Dropbox and Google Drive arises
when several people edit files simultaneously: it can be difficult
detect who did what when, roll back to previous versions, and to
manually merge the edits when these are incompatible. Then one needs
more sophisticated tools, which means a <em>true version control system</em>.
The following text aims at providing you with the minimum information
to started with Git, the leading version control system, combined
with project hosting services for file storage.

<h2 id="___sec2">Repositories and local copies </h2>

<p>
The mentioned services host all your files in a specific project in what
is known as a <em>repository</em>, or <em>repo</em> for short.  When a copy of the
files are wanted on a certain computer, one clones the repository on
that computer.  This creates a local copy of the files. Now files can
be edited, new ones can be added, and files can be deleted.  These
changes are then brought back to the repository.  If users at
different computers synchronize their files frequently with the
repository, most modern version control systems will be able to merge
changes in files that have been edited simultaneously on different
computers. This is perhaps one of the most useful features of project
hosting services. However, the merge functionality clearly works best
for pure text files and less well for binary files, such as PDF files,
MS Word or Excel documents, and OpenOffice documents.

<h2 id="___sec3">Installing Git </h2>

<p>
The installation of Git on various systems is described on the <a href="http://git-scm.com/" target="_self">Git
website</a> under the <em>Download</em> section.  Git
involves compiled code so it is most convenient to download a
precompiled binary version of the software on Windows, Mac and other
Linux computers.  On Ubuntu or any Debian-based system the relevant
installation command is

<p>
<!-- begin verbatim block  sys-->
<pre><code>Terminal&gt; sudo apt-get install git gitk git-doc
</code></pre>
<!-- end verbatim block -->

<p>
This tutorial explains Git interaction through command-line applications
in a terminal window. There are numerous <a href="https://git.wiki.kernel.org/index.php/InterfacesFrontendsAndTools#Graphical_Interfaces" target="_self">graphical user interfaces to
Git</a>. Three examples are
<a href="http://git-cola.github.com/downloads.html" target="_self">git-cola</a>,
<a href="https://code.google.com/p/tortoisegit/" target="_self">TortoiseGit</a>, and
<a href="http://sourcetreeapp.com/" target="_self">SourceTree</a>.

<h2 id="bitgit:git:config">Configuring Git</h2>

<p>
Make a file <code>.gitconfig</code> in your home directory with information on
your full name, email address, your favorite text editor, and
the name of an &quot;excludes file&quot; which defines the file types that Git
should omit when bringing new directories under version control.
Here is a simplified version of the author's <code>.gitconfig</code> file:
<!-- begin verbatim block  dat-->
<pre><code>[user]
name = Hans Petter Langtangen
email = hpl@simula.no
editor = emacs

[core]
excludesfile = ~/.gitignore
</code></pre>
<!-- end verbatim block -->

<p>
The &quot;excludes file&quot; is called <code>.gitignore</code> and must list,
using the Unix Shell Wildcard notation,
the type of files that you do not need to have under version control,
because they represent garbage or temporary information,
or they can easily be regenerated from
some other source files. A suggested <a href="http://hplgit.github.com/teamods/bitgit/src-bitgit/.gitignore" target="_self"><tt>.gitignore</tt></a> file looks like

<p>
<!-- begin verbatim block  dat-->
<pre><code># compiled files:
*.o
*.so
*.a
# temporary files:
*.bak
*.swp
*~
.*~
*.old
tmp*
temp*
.#*
\#*
# tex files:
*.log
*.dvi
*.aux
*.blg
*.idx
*.nav
*.out
*.toc
*.snm
*.vrb
# eclipse files:
*.cproject
*.project
# misc:
.DS_Store
</code></pre>
<!-- end verbatim block -->
Be critical to what kind of files you really need a full history of.
For example, you do not want to populate the repository with
big graphics files of the type that can easily be regenerated by
some program.

<p>
<!-- !split -->

<h1 id="bitgit:github">GitHub</h1>

<p>
Go to <code>github.com</code> and create an account. Then go to your account
settings (icon in the upper left corner of the page),
choose <em>SSH Keys</em>, and provide your SSH key
unless you have already registered this key with another GitHub
account (see  <a href="#appendix:github:multiple:accounts">Appendix: Working with multiple GitHub accounts</a>).
Often, it is just a
matter of pasting the contents of <code>id_rsa.pub</code> or <code>id_dsa.pub</code> files,
located in the
<code>.ssh</code> subdirectory of your home directory, into the <em>Key</em> box in the
web page. Make sure to just cut and paste the text from, e.g., <code>id_rsa.pub</code>
without any extra whitespaces or other text. How to generate these
files is described in the link <em>generating SSH keys</em> above the SSH Keys
box.

<p>
If the account is a project account and not a personal account,
I do not recommend to provide an SSH key although it can be
done (see  <a href="#appendix:github:multiple:accounts">Appendix: Working with multiple GitHub accounts</a>). It is easier
to log in and add collaborators using their personal GitHub usernames.

<h2 id="___sec6">Creating a new project </h2>

<p>
Click on <em>New repository</em> on the main page and fill out a project
name, here <em>My Project</em>, click the check button <em>Initialize this
repository with a README</em>, and click on <em>Create repository</em>.
Unless you pay, all repos are public, but students and teachers
can request <a href="https://github.com/edu" target="_self">free, private repos</a>.

<p>
The next step is to clone the project on your personal computer. Click
on the <em>SSH</em> button to see the address of the project, and
paste this address into a terminal window, after <code>git clone</code>:

<p>
<!-- begin verbatim block  sys-->
<pre><code>Terminal&gt; git clone git://github.com:user/My-Project.git
</code></pre>
<!-- end verbatim block -->
Make sure you substitute <code>user</code> by your own username on GitHub.

<p>
The result of the <code>git clone</code> command is a new directory <code>My-Project</code>.
It contains the file <code>.git</code>, which shows that it is a Git repository.
It also contains a default <code>README.md</code> file with the project name and
description. The extension <code>.md</code> signifies a file written in the
<a href="http://daringfireball.net/projects/markdown/" target="_self">Markdown</a> format.
You may use the <a href="http://docutils.sourceforge.net/rst.html" target="_self">reStructuredText</a> format as an alternative
(<code>README.rst</code>), or simply write a plain text file (<code>README</code>),
but the <code>git mv</code> command must be used to change the filename.

<p>
You can now add files and directories into the <code>My-Project</code> directory.
When your initial file collection has the desired form, you must
run
<!-- begin verbatim block  sys-->
<pre><code>Terminal&gt; git add .
Terminal&gt; git commit -am 'First set of files.'
Terminal&gt; git push -u origin master
</code></pre>
<!-- end verbatim block -->
The daily file operations are explained in the section <a href="#bitgit:git">Using Git</a>.

<h3 id="___sec7">Collaborating </h3>

<p>
To give others permissions to push their edits of files to the
repository, you click on the <em>Settings</em> link in the right sidebar,
then click on <em>Collaborators</em> on the left, and fill in the name
of a collaborator (her or his username on GitHub).
Many find it convenient to be notified in email when others have
pushed a new version of the files to the repo. Click on <em>Service Hooks</em>
in the project's <em>Settings</em> menu, choose <em>Email</em>, fill in
at most two whitespace-separated email addresses, mark the
<em>Send from Author</em> and <em>Active</em> boxes, and click on <em>Update Settings</em>.
More addresses must be dealt with through a <a href="http://stackoverflow.com/questions/7015300/receiving-emails-on-git-push" target="_self">mailing list</a>
and filling in the name of that list.

<p>
Anyone who participates in a project (has write access) or watches a
project (having clicked the <em>watch</em> button) can monitor the
development of the activity on their GitHub main page. Go to <em>Account Settings</em>
and choose <em>Notification Center</em>.  There you see two sections,
<em>Participating</em> and <em>Watching</em>, for those participating in the project
(granted write access) and those watching the project (having clicked
the <em>watch</em> button), respectively.
<!-- No, this doesn't work: Clicking the <em>Email</em> button turns -->
<!-- on email notifications to those participating and/or watching. -->

<h2 id="___sec8">Wiki pages </h2>

<p>
With every GitHub project there is an option to create wiki pages.
Click on the <em>Wiki</em> button in the right sidebar on the main page of
the project. Click on <em>New Page</em> to create a new page. The wiki pages
can be written in different markup languages. Markdown is the default
choice, but you can alternatively use MediaWiki and
reStructuredText. Unfortunately, <em>GitHub wiki pages do not allow LaTeX
mathematics through MathJax</em>, even though MediaWiki has support for
LaTeX (the reason is <a href="http://stackoverflow.com/questions/16889421/how-to-insert-javascript-to-enable-mathjax-on-github-wiki-pages" target="_self">security issues</a>).

<p>
The wiki pages can be written and maintained through the web browser
interface, but it is usually more convenient to clone them on
your computer as this makes it easy to add figures and other documents
you may want to link to. It also makes it straightforward to edit
the wiki text in your favorite text editor. The wiki pages are
stored in a separate repo and can be cloned by
<!-- begin verbatim block  sys-->
<pre><code>Terminal&gt; git clone git://github.com/user/My-Project.wiki.git
</code></pre>
<!-- end verbatim block -->
This command makes a local copy of the pages in the directory
<code>My-Project.wiki</code>, which you may prefer to have at the same level
as the project directory itself in your directory tree.

<p>
Each wiki page has its own file, where the extension reflects
the markup language used, e.g., <code>.md</code> for Markdown, <code>.rest</code> for
reStructuredText, <code>.mediawiki</code> for MediaWiki,
and <code>.creole</code> for Creole wiki. The wiki files are handled as other files in a
GitHub project, i.e., you need to pull before editing and then
perform commit and push. After the push you can reload the page
in the web browser to monitor the effect.

<p>
You may consider having the original text in <code>doconce</code> format and
generate the wiki in the reStructuredText or MediaWiki format.

<p>
Do changes, commit the usual way, and push by
<!-- begin verbatim block  sys-->
<pre><code>Terminal&gt; git push git@github.com:user/My-project.wiki.git
</code></pre>
<!-- end verbatim block -->
The address can be stored as <code>url</code> in <code>.git/config</code> in the
root directory of the wiki project so that just a standard
<code>git push</code> works.

<h2 id="___sec9">Project web pages </h2>

<p>
HTML pages stored in your repo cannot be linked to and properly
rendered as web pages.
Say you have some HTML file <code>doc/file.html</code> in the repo.
The normal link to the file is

<p>
<!-- begin verbatim block -->
<pre><code>https://github.com/user/my-project/blob/master/doc/file.html
</code></pre>
<!-- end verbatim block -->
which shows up as a nicely typeset, colorful HTML code.
The raw text file,

<p>
<!-- begin verbatim block -->
<pre><code>https://raw.githubusercontent.com/user/my-project/master/doc/file.html
</code></pre>
<!-- end verbatim block -->
shows up as pure text in a browser. If one wants to see the file
rendered as HTML code, one can view it through <code>htmlpreview.github.io</code>.
This means that one can use the link

<p>
<!-- begin verbatim block -->
<pre><code>http://htmlpreview.github.io/?https://raw.githubusercontent.com/user/my-project/master/doc/file.html
</code></pre>
<!-- end verbatim block -->
to produce the HTML document in a browser.

<p>
However, there is another technique available where all HTML files in
a special branch <em>gh-pages</em> of the repository are automatically
rendered correctly as HTML documents in a browser. This is
the recommended technique for publishing a collection of HTML files
related to the project in a simple and convenient way.
The recipe is described in detail below.

<ol>
<li> Go to the  project page on <code>github.com</code> and click <em>Settings</em>.</li>
<li> Click on <em>Automatic Page Generator</em> under the <em>GitHub Pages</em>.</li>
<li> Proceed clicking <em>Continue to Layouts</em>, choose
   a design of the <code>index.html</code> page that GitHub will
   create for you, and click <em>Publish</em>.</li>
<li> Go to the root directory of the project, <code>My-Project</code>
   and run <code>git fetch origin</code>.</li>
<li> Run <code>git checkout gh-pages</code>.</li>
</ol>

You have now a <em>new branch</em> called gh-pages of your project
containing an <code>index.html</code> file and directories for JavaScript
programs and CSS style sheets in the root directory. The gh-pages
branch will also all files <em>not</em> contained in the <em>master branch</em>,
typically redundant files you have generated and which should not be
stored in the version control system (remove these manually with <code>git
rm</code>).  You can populate the root directory and subdirectories of your
gh-pages branch with HTML and other files as you like. The key issue
is that the people out there will only see the web pages that
correspond to your HTML files in the gh-pages branch!

<p>
The <code>index.html</code> page is invoked by the web address

<p>
<!-- begin verbatim block -->
<pre><code>http://user.github.io/My-Project/index.html
</code></pre>
<!-- end verbatim block -->
where <code>user</code> is the GitHub
username and <code>My-Project</code> is the project name.

<p>
<!-- Update this info when I have maintained gh-pages for a while! -->
<!-- Could also have a special section on branching in git (above, -->
<!-- then the info here is simple... YES!). -->

<p>
The web pages and project files are now in two different branches.
To see the branches, type <code>git branch</code>, and the one you are in will
be marked with <code>*</code> in the output. Switching to the master branch
is done by <code>git checkout master</code>. Similarly, <code>git checkout gh-pages</code>
switches to the gh-pages branch.

<p>
My personal preference is to have the master and gh-pages
synchronized, at least in projects where I want to link to various
source code files or other files from the web documentation.
Sometimes I also update files in the gh-pages branch without
remembering to switch to the master branch.  To this end, one needs
to <em>merge</em> the branches, i.e., automatically edit files
in the current branch such that they are up-to-date and
identical to files in another branch.

<p>
To merge the current branch with some branch named <code>otherbranch</code>, run
<!-- begin verbatim block  sys-->
<pre><code>Terminal&gt; git merge otherbranch
</code></pre>
<!-- end verbatim block -->
Git applies smart algorithms that very often manage to merge the
files without human interaction. However, occasionally these algorithms
are not able to resolve conflicts between two files.
A message about the failure of the merge is seen in the terminal
window, and the corresponding files have markers in them showing
which sections that needs manual editing to resolve the conflicts.
Run
<code>git diff</code> to show the problems (you can tailor this command to your
needs as explained in the section <a href="#bitgit:git:fetch">Replacing pull by fetch and merge</a>). After a manual
edit, do <code>git commit -a</code>. More details on merging appears
in the section <a href="#bitgit:git:merge">Merging files with Git</a>.

<p>
If you want to keep the master branch and the gh-pages branch
synchronized,
start with merging the gh-pages branch with the master
branch and push the complete file collection to the gh-pages branch.
Then switch to the master
branch and merge with gh-pages so you get the autogenerated
<code>index.html</code> file and associated files and directories for web pages
in the root directory of the master branch as well:

<p>
<!-- begin verbatim block  sys-->
<pre><code>Terminal&gt; git merge master
Terminal&gt; touch .nojekyll
Terminal&gt; git push origin gh-pages
Terminal&gt; git checkout master
Terminal&gt; git merge gh-pages
</code></pre>
<!-- end verbatim block -->
You <em>must</em> add an empty file <code>.nojekyll</code> in the top
directory of the project pages if you want to use Sphinx-generated
HTML pages (or other pages using javascripts, style sheets, and images
in subdirectories whose names start with an underscore).

<p>
You can now add the documentation to the project files and
maintain them in the master branch.
Before publishing documents online,
make sure to update the gh-pages branch by

<p>
<!-- begin verbatim block  sys-->
<pre><code>Terminal&gt; git commit -am 'Ensure commit of master branch'
Terminal&gt; git push origin master
Terminal&gt; git checkout gh-pages
Terminal&gt; git pull origin gh-pages
Terminal&gt; git merge master
Terminal&gt; git push origin gh-pages
Terminal&gt; git checkout master
</code></pre>
<!-- end verbatim block -->

<p>
Personally, I like to move the generated <code>index.html</code> file and all
associated scripts, stylesheets, and images from the root directory to
some more isolated place, say <code>doc/web</code>:

<p>
<!-- begin verbatim block  sys-->
<pre><code>Terminal&gt; git mv index.html params.json stylesheets/ images/ \
                 javascripts/ doc/web/
</code></pre>
<!-- end verbatim block -->
The URL of the <code>index.html</code> file is
<!-- begin verbatim block -->
<pre><code>http://user.github.io/My-Project/doc/web/index.html
</code></pre>
<!-- end verbatim block -->

<p>
<!-- See <a href="https://github.com/daler/sphinxdoc-test" target="_self"><tt>https://github.com/daler/sphinxdoc-test</tt></a> -->
<!-- for ideas on how to do sphinx documentation without full -->
<!-- mirroring as I do. -->
<!-- See also <a href="http://lucasbardella.com/report/hosting-your-sphinx-docs-in-github/" target="_self"><tt>http://lucasbardella.com/report/hosting-your-sphinx-docs-in-github/</tt></a> -->
<!-- Sphinx extension for github: <a href="https://github.com/michaeljones/sphinx-to-github" target="_self"><tt>https://github.com/michaeljones/sphinx-to-github</tt></a> -->

<p>
<!-- The problem can also be circumvented by -->
<!-- installing special Sphinx extensions ("sphinx-to-github": -->
<!-- "https://github.com/michaeljones/sphinx-to-github" or "github-tools": -->
<!-- "http://pydoc.net/github-tools/0.1.3/"). -->

<p>
Linking to source code files or other files in the project is easy:
just find the file in GitHub's web interface, choose which version of
the file you want to link to (nicely HTML formatted version or the raw
file), right-click on the link, choose <em>Copy Link</em>, and paste the
link into the document you want. You can test that the link works by
the Unix command <code>curl -O &lt;link&gt;</code>. Note that the link to a file
is different from the source file's intuitive path in the repository.
Typically, a source file <code>dir/f.py</code> in project <code>prj</code> is reached
through
<!-- begin verbatim block -->
<pre><code>https://github.com/user/prj/blob/master/dir/f.py?raw=true
</code></pre>
<!-- end verbatim block -->

<p>
Sometimes you want to link to another HTML file, PDF file, movie file,
or a file that is to be interpreted as a web resource by the browser.
Do not use the path to the file in the repo as explained above as it will
just bring the reader to the repo page. Instead, make sure the file is in
the gh-pages branch and use a local link, like <code>../doc.pdf</code>, or the
complete gh-pages URL to the file, say
<!-- begin verbatim block -->
<pre><code>http://user.github.com/My-Project/doc/misc/doc.pdf
</code></pre>
<!-- end verbatim block -->

<p>
<div class="alert alert-block alert-notice alert-text-normal">
<b>Tip.</b>
<p>
The ordinary GitHub URL of image files can be used
in web pages to insert images from your repo, provided the image files
are in the <em>raw</em> format - click the <em>Raw</em> button when viewing a file at
<code>github.com</code> and use the corresponding URL in the <code>img</code> tag in
the HTML code.
</div>


<h2 id="___sec10">User web pages </h2>

<p>
GitHub also allows you to create user pages and organization pages not
tied to any specific project.
Your personal site has address
<code>http://user.github.com</code>.
Go to your home page on <code>github.com</code> and click <em>New repository</em>,
and give it the project name <code>user.github.com</code>.
Then follow the instructions that come up:
<!-- begin verbatim block  sys-->
<pre><code>Terminal&gt; mkdir user.github.com
Terminal&gt; cd user.github.com
Terminal&gt; git init
Terminal&gt; # make an index.html file with some test text
Terminal&gt; git add index.html
Terminal&gt; git commit -m 'First commit'
Terminal&gt; git remote add origin \
          git@github.com:user/user.github.com.git
Terminal&gt; git push -u origin master
</code></pre>
<!-- end verbatim block -->
Go to <code>http://user.github.com</code> and see how the <code>index.html</code> is
rendered. You can now add various contents as in any ordinary
Git repository.
If you want to use Sphinx generated HTML pages, recall to add an empty file
<code>.nojekyll</code>.

<p>
<!-- Use gh-pages in a subdirectory of the master branch: <a href="https://gist.github.com/825950" target="_self"><tt>https://gist.github.com/825950</tt></a> -->

<p>
<!-- !split -->

<h1 id="bitgit:git">Using Git</h1>

<p>
Most Mac and Linux users prefer to work with Git via commands in a
terminal window. Windows users may prefer a graphical user interface (GUI),
and there are many <a href="http://git-scm.com/downloads/guis" target="_self">options</a> in
this respect. There are also GUIs for Mac users.
Here we concentrate on the efficient command-line interface to Git.

<h2 id="___sec12">Basic Git commands </h2>

<h3 id="___sec13">Cloning </h3>

<p>
You get started with your project on a new machine, or another user
can get started with the project,
by running
<!-- begin verbatim block  sys-->
<pre><code>Terminal&gt; git clone git@github.com:user/My-Project.git
Terminal&gt; cd My-Project
ls
</code></pre>
<!-- end verbatim block -->
Recall to replace <code>user</code> by your real username and <code>My-Project</code> by the
actual project name.

<h3 id="___sec14">The pull-change-push cycle </h3>

<p>
The typical work flow with the "My Project" project starts with
updating the local repository by going to the <code>My-Project</code> directory
and writing
<!-- begin verbatim block  sys-->
<pre><code>Terminal&gt; git pull origin master
</code></pre>
<!-- end verbatim block -->
You may want to do <code>git fetch</code> and <code>git merge</code> instead
of <code>git pull</code> as explained in the section <a href="#bitgit:git:fetch">Replacing pull by fetch and merge</a>,
especially if you work with branches.

<p>
You can now edit files, make new files, and make new directories.
New files and directories must be added with <code>git add</code>.
There are also Git commands for deleting, renaming, and moving
files. Typical examples on these Git commands are
<!-- begin verbatim block  sys-->
<pre><code>Terminal&gt; git add file2.* dir1 dir2  # add files and directories
Terminal&gt; git rm file3
Terminal&gt; git rm -r dir2
Terminal&gt; git mv oldname newname
Terminal&gt; git mv oldname ../newdir
</code></pre>
<!-- end verbatim block -->
When your chunk of work is ready,
it is time to commit your changes (note the <code>-am</code> option):
<!-- begin verbatim block  sys-->
<pre><code>Terminal&gt; git commit -am 'Description of changes.'
</code></pre>
<!-- end verbatim block -->
If typos or errors enter the message, the <code>git commit --amend</code> command
can be used to reformulate the message.  Running <code>git diff</code> prior to
<code>git commit</code> makes it
easier to formulate descriptive commit messages since this command
gives a listing of all the changes you have made to the files since
the last commit or pull command.

<p>
You may perform many commits (to keep track of small changes), before
you push your changes to the global repository:

<p>
<!-- begin verbatim block  sys-->
<pre><code>Terminal&gt; git push origin master
</code></pre>
<!-- end verbatim block -->

<p>
<div class="alert alert-block alert-warning alert-text-normal">
<b>Do pull and push often!</b>
<p>
It is recommended to pull, commit, and push
frequently if the work takes place in several
clones of the repo (i.e., there are many users or you work with the
repo on different
computers). Infrequent push and pull easily leads to merge problems
(see the section <a href="#bitgit:git:merge">Merging files with Git</a>). Also remember that others
(human and machines) cannot get your changes before they are pushed!
</div>


<p>
<div class="alert alert-block alert-notice alert-text-normal">
<b>Do not forget to add important files.</b>
<p>
You should run <code>git status -s</code> frequently to see the status of
files: <code>A</code> for added, <code>M</code> for modified, <code>R</code> for renamed,
and <code>??</code> for not being registered in the repo. Pay particular attention
to the <code>??</code> files and examine if all of them are redundant or easily
regenerated from other files - of not, run <code>git add</code>.
</div>


<p>
<div class="alert alert-block alert-notice alert-text-normal">
<b>Make sure you have a <code>.gitignore</code> file.</b>
<p>
The simplest way of adding files to the repo is to do

<p>
<!-- begin verbatim block  sys-->
<pre><code>Terminal&gt; git add .
</code></pre>
<!-- end verbatim block -->
The dot adds every file, and this is seldom what you want, since
your directories frequently contain large redundant files or files
that can easily be regenerated. You therefore need a
<code>.gitignore</code> file, see the section <a href="#bitgit:git:config">Configuring Git</a>,
either in your home directory or in the root directory of the repo.
The <code>.gitignore</code> file will ignore undesired files when you do
<code>git add .</code>.
</div>


<h3 id="___sec15">Viewing the history of files </h3>

<p>
A nice graphical tool allows you to view all changes, or just
the latest ones:
<!-- begin verbatim block  sys-->
<pre><code>Terminal&gt; gitk --all
Terminal&gt; gitk --since=&quot;2 weeks ago&quot;
</code></pre>
<!-- end verbatim block -->

<p>
You can also view changes to all files, some selected ones, or
a subdirectory:
<!-- begin verbatim block  sys-->
<pre><code>Terminal&gt; git log -p                 # all changes to all files
Terminal&gt; git log -p filename        # changes to a specific file
Terminal&gt; git log --stat --summary   # compact summary
Terminal&gt; git log --stat --summary subdir
</code></pre>
<!-- end verbatim block -->
Adding <code>--follow</code> will print the history of file versions before the
file got its present name.

<p>
To show the author who is responsible for the last modification of each
line in the file, use <code>git blame</code>:
<!-- begin verbatim block  sys-->
<pre><code>Terminal&gt; git blame filename
Terminal&gt; git blame --since=&quot;1 week&quot; filename
</code></pre>
<!-- end verbatim block -->
A useful command to see the history of who did what, where individual
edits of words are highlighted (<code>--word-diff</code>), is
<!-- begin verbatim block  sys-->
<pre><code>git log -p --stat --word-diff filename
</code></pre>
<!-- end verbatim block -->
Removed words appear in brackets and added words in curly braces.

<p>
Looking for when a particular piece of text entered or left the file,
say the text <code>def myfunc</code>, one can run
<!-- begin verbatim block  sys-->
<pre><code>Terminal&gt; git log -p --word-diff --stat -S'def myfunc' filename
</code></pre>
<!-- end verbatim block -->
This is useful to track down particular changes in the files to see when
they occurred and who introduced them. One can also search for regular
expressions instead of exact text: just replace <code>-S</code> by <code>-G</code>.

<h3 id="___sec16">Retrieving old files </h3>

<p>
Occasionally you need to go back to an earlier version of a file,
e.g., a file called <code>f.py</code>. Start with viewing the history:

<p>
<!-- begin verbatim block  sys-->
<pre><code>Terminal&gt; git log f.py
</code></pre>
<!-- end verbatim block -->
Find a commit candidate from the list that you will compare the
present version to, copy the commit hash (string like
<code>c7673487...</code>), and run
<!-- begin verbatim block  sys-->
<pre><code>Terminal&gt; git diff c7673487763ec2bb374758fb8e7efefa12f16dea f.py
</code></pre>
<!-- end verbatim block -->
where the long string is the relevant commit hash. You can now view the
differences between the most recent version and the one in
the commit you picked (see the section <a href="#bitgit:git:fetch">Replacing pull by fetch and merge</a> for how to
configure the tools used by the <code>git diff</code> command). If you want to restore the old file, write
<!-- begin verbatim block  sys-->
<pre><code>Terminal&gt; git checkout c7673487763ec2bb374758fb8e7efefa12f16dea f.py
</code></pre>
<!-- end verbatim block -->
To go back to another version (the most recent one, for instance),
find the commit hash with <code>git log f.py</code>, and do <code>get checkout
&lt;commit hash&gt; f.py</code>.

<p>
If <code>f.py</code> changed name from <code>e.py</code> at some point and you want
<code>e.py</code> back, run <code>git log --follow f.py</code> to find the commit
when <code>e.py</code> existed, and do a <code>git checkout &lt;commit hash&gt; e.py</code>.

<p>
In case <code>f.py</code> no longer exists, run <code>git log -- f.py</code> to
see its history before deletion. The last commit shown does
not contain the file, so you need to check out the next last
to retrieve the latest version of a deleted file.

<p>
Often you just need to <em>view</em> the old file, not replace the current
one by the old one, and then <code>git show</code> is handy. Unfortunately,
it requires the full path from the root git directory:
<!-- begin verbatim block  sys-->
<pre><code>Terminal&gt; git show \
          c7673487763ec2bb374758fb8e7efefa12f16dea:dir1/dir2/f.py
</code></pre>
<!-- end verbatim block -->

<h3 id="___sec17">Reset the entire repo to an old version </h3>

<p>
Run <code>git log</code> on some file and find the commit hash of the date
or message when want to go back to. Run <code>git checkout &lt;commit hash&gt;</code>
to change all files to this state.
The problem of going back to the most recent state is that <code>git log</code>
has no newer commits than the one you checked out. The trick is to say
<code>git checkout master</code> to set all files to most recent version again.

<p>
If you want to reset all files to an old version and commit this state
as the valid present state, you do

<p>
<!-- begin verbatim block  sys-->
<pre><code>Terminal&gt; git checkout c7673487763ec2bb374758fb8e7efefa12f16dea .
Terminal&gt; git commit -am 'Resetting to ...'
</code></pre>
<!-- end verbatim block -->
Note the period at the end of the first command (without it, you only
get the possibility to look at old files, but the next commit is not
affected).

<h3 id="___sec18">Going back to a previous commit </h3>

<p>
Sometimes accidents with many files happen and you want to go back
to the last commit. Find the hash of the last commit and do

<p>
<!-- begin verbatim block  sys-->
<pre><code>Terminal&gt; git reset --hard c867c487763ec2
</code></pre>
<!-- end verbatim block -->
This command destroys <em>everything</em> you have done since the last commit.
To push it as the new state of the repo, do

<p>
<!-- begin verbatim block  sys-->
<pre><code>Terminal&gt; git push origin HEAD --force
</code></pre>
<!-- end verbatim block -->

<h2 id="bitgit:git:merge">Merging files with Git</h2>

<p>
The <code>git pull</code> command fetches new files from the repository and
tries to perform an automatic merge if there are conflicts between
the local files and the files in the repository. Alternatively,
you may run <code>git fetch</code> and <code>git merge</code> to do the same
thing as described in the section <a href="#bitgit:git:fetch">Replacing pull by fetch and merge</a>.
We shall now address what do to if the merge goes wrong, which
occasionally happens.

<p>
Git will write a message in the terminal window
if the merge is unsuccessful for one or
more files. These files will have to be edited manually.
Merge markers of the type <code>&gt;&gt;&gt;&gt;&gt;</code>, <code>======</code>, and <code>&lt;&lt;&lt;&lt;&lt;</code> have been
inserted by Git to mark sections of a file where the version in the
repository differ from the local version. You must decide which
lines that are to appear in the final, merged version. When done,
perform <code>git commit</code> and the conflicts are resolved.

<p>
Graphical merge tools may ease the process of merging text files.  You
can run <code>git mergetool --tool=meld</code> to open the merge tool <code>meld</code> for
every file that needs to be merged (or specify the name of a
particular file). Other popular merge tools supported by Git are
<code>araxis</code>, <code>bc3</code>, <code>diffuse</code>, <code>ecmerge</code>, <code>emerge</code>, <code>gvimdiff</code>, <code>kdiff3</code>,
<code>opendiff</code>, <code>p4merge</code>, <code>tkdiff</code>, <code>tortoisemerge</code>, <code>vimdiff</code>, and
<code>xxdiff</code>.

<p>
Below is a Unix shell script illustrating how to make a global
repository in Git, and how two users clone this repository and
perform edits in parallel. There is one file <code>myfile</code> in the
repository.

<p>
<!-- begin verbatim block  shpro-->
<pre><code>#!/bin/sh
# Demo script for exemplifying git and merge

rm -rf tmp1 tmp2 tmp_repo   # Clean up previous runs

mkdir tmp_repo   # Global repository for testing
cd tmp_repo
git --bare init --shared
cd ..

# Make a repo that can be pushed to tmp_repo
mkdir _tmp
cd _tmp
cat &gt; myfile &lt;&lt;EOF
This is a little
test file for
exemplifying merge
of files in different
git directories.
EOF
git init
git add .   # Add all files not mentioned in ~/.gitignore
git commit -am 'first commit'
git push ../tmp_repo master
cd ..
rm -rf _tmp

# Make a new hg repositories tmp1 and tmp2 (two users)
git clone tmp_repo tmp1
git clone tmp_repo tmp2
# Change myfile in the directory tmp1
cd tmp1
# Edit myfile: insert a new second line
perl -pi -e 's/a little\n/a little\ntmp1-add1\n/g' myfile
# Register change in local repository
git commit -am 'Inserted a new second line in myfile.'
# Look at changes in this clone
git log -p
# or a more compact summary
git log --stat --summary
# or graphically
#gitk
# Register change in global repository tmp_repo
git push origin master
cd ..

# Change myfile in the directory tmp2 &quot;in parallel&quot;
cd tmp2
# Edit myfile: add a line at the end
cat &gt;&gt; myfile &lt;&lt;EOF
tmp2-add1
EOF
# Register change locally
git commit -am 'Added a new line at the end'
# Register change globally
git push origin master
# Error message: global repository has changed,
# we need to pull those changes to local repository first
# and see if all files are compatible before we can update
# our own changes to the global repository.
# git writes
#To /home/hpl/vc/scripting/manu/py/bitgit/src-bitgit/tmp_repo
# ! [rejected]        master -&gt; master (non-fast-forward)
#error: failed to push some refs to ...

git pull origin master
# git writes:
#Auto-merging myfile
#Merge made by recursive.
# myfile |    1 +
# 1 files changed, 1 insertions(+), 0 deletions(-)
cat myfile  # successful merge!
git commit -am merge
git push origin master
cd ..

# Perform new changes in parallel in tmp1 and tmp2,
# this time causing hg merge to fail

# Change myfile in the directory tmp1
cd tmp1
# Do it all right by pulling and updating first
git pull origin master
# Edit myfile: insert &quot;just&quot; in first line.
perl -pi -e 's/a little/tmp1-add2 a little/g' myfile
# Register change in local repository
git commit -am 'Inserted &quot;just&quot; in first line.'
# Register change in global repository tmp_repo
git push origin master
cd ..

# Change myfile in the directory tmp2 &quot;in parallel&quot;
cd tmp2
# Edit myfile: replace little by modest
perl -pi -e 's/a little/a tmp2-replace1\ntmp2-add2\n/g' myfile
# Register change locally
git commit -am 'Replaced &quot;little&quot; by &quot;modest&quot;'
# Register change globally
git push origin master
# Not possible: need to pull changes in the global repository
git pull origin master
# git writes
#CONFLICT (content): Merge conflict in myfile
#Automatic merge failed; fix conflicts and then commit the result.
# we have to do a manual merge
cat myfile
echo 'Now you must edit myfile manually'
</code></pre>
<!-- end verbatim block -->

<p>
You may run this file <a href="http://hplgit.github.com/teamods/bitgit/_static-bitgit/git_merge.sh" target="_self"><tt>git_merge.sh</tt></a> named
by <code>sh -x git_merge.sh</code>.
At the end, the versions of <code>myfile</code> in the
repository and the <code>tmp2</code> directory are in conflict. Git tried
to merge the two versions, but failed. Merge markers are left in
<code>tmp2/myfile</code>:

<p>
<!-- begin verbatim block  dat-->
<pre><code>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD
This is a tmp2-replace1
tmp2-add2

=======
This is tmp1-add2 a little
&gt;&gt;&gt;&gt;&gt;&gt;&gt; ad9b9f631c4cc586ea951390d9415ac83bcc9c01
tmp1-add1
test file for
exemplifying merge
of files in different
git directories.
tmp2-add1
</code></pre>
<!-- end verbatim block -->
Launch a text editor and edit the file, or use <code>git mergetool</code>,
so that the file becomes correct.
Then run <code>git commit -am merge</code> to finalize the merge.

<h2 id="bitgit:git:branch:stash">Git working style with branching and stashing</h2>

<p>
<!-- git clone is without branches, say something about that in clone -->

<p>
Branching and stashing are nice features of Git that allow you to try
out new things without affecting the stable version of your files.
Usually, you extend and modify files quite often and perform a <code>git
commit</code> every time you want to record the changes in your local
repository. Imagine that you want to correct a set of errors in some
files and push these corrections immediately.  The problem is that
such a push will also include the latest, yet unfinished files that you
have committed.

<h3 id="___sec21">Branching </h3>

<p>
A better organization of your work would
be to keep the latest, ongoing
developments separate from the more official and stable version
of the files. This is easily achieved by creating a separate branch
where new developments takes place:

<p>
<!-- begin verbatim block  sys-->
<pre><code>Terminal&gt; git branch newstuff      # create new branch
Terminal&gt; git checkout newstuff
Terminal&gt; # extend and modify files...
Terminal&gt; git commit -am 'Modified ... Added a file on ...'
Terminal&gt; git checkout master      # swith back to master
Terminal&gt; # correct errors
Terminal&gt; git push origin master
Terminal&gt; git checkout newstuff    # switch to other branch
Terminal&gt; git merge master         # keep branch up-to-date w/master
Terminal&gt; # continue development work...
Terminal&gt; git commit -am 'More modifications of ...'
</code></pre>
<!-- end verbatim block -->
At some point, your developments in <code>newstuff</code>
are mature enough to be incorporated
in the master branch:

<p>
<!-- begin verbatim block  sys-->
<pre><code>Terminal&gt; git checkout newstuff
Terminal&gt; git merge master        # synchronize newstuff w/master
Terminal&gt; git checkout master
Terminal&gt; git merge newstuff      # synchronize master w/newstuff
</code></pre>
<!-- end verbatim block -->
You no longer need the <code>newstuff</code> branch and can delete it:

<p>
<!-- begin verbatim block  sys-->
<pre><code>Terminal&gt; git branch -d newstuff
</code></pre>
<!-- end verbatim block -->
This command deletes the branch locally. To also delete the branch
in the remote repo, run

<p>
<!-- begin verbatim block  sys-->
<pre><code>Terminal&gt; git push origin --delete newstuff
</code></pre>
<!-- end verbatim block -->

<p>
You can learn more in an <a href="http://pcottle.github.io/learnGitBranching/" target="_self">excellent introduction and demonstration of Git branching</a>.

<h3 id="___sec22">Stashing </h3>

<p>
It is not possible to switch branches unless you have committed the
files in the current branch. If your work on some files is in a mess
and you want to change to another branch or fix other files in the
current branch, a &quot;global&quot; commit affecting all files might be
immature.  Then the <a href="http://git-scm.com/book/en/Git-Tools-Stashing" target="_self"><tt>git stash</tt></a> command is handy. It
records the state of your files and sets you back to the state of the
last commit in the current branch. With <code>git stash apply</code> you will update the
files in this branch to the state when you did the last <code>git
stash</code>.

<p>
Let us explain a typical case.  Suppose you have performed some
extensive edits in some files and then you are suddenly
interrupted. You need to fix some typos in some other files, commit
the changes, and push. The problem is that many files are in an
unfinished state - in hindsight you realize that those files should
have been modified in a separate branch.  It is not too late to create
that branch! First run <code>git stash</code> to get the files back to the state
they were at the last commit. Then run <code>git stash branch newstuff</code> to
create a new branch <code>newstuff</code> containing the state of the files when
you did the (last) <code>git stash</code> command.  Stashing used this way is a
convenient technique to move some immature edits after the last commit
out in a new branch for further experimental work.

<p>
<div class="alert alert-block alert-warning alert-text-normal">
<b>Warning.</b>
<p>
You can get the stashed files back by <code>git stash apply</code>. It is
possible to multiple <code>git stash</code> and <code>git stash apply</code>
commands. However, it is easy to run into trouble with multiple
stashes, especially if they occur in multiple branches, as it becomes
difficult to recognize which stashes that belong to which branch.  A
good advice is therefore to do <code>git stash</code> <em>only once</em> to get back to
a clean state and then move the unfinished messy files to a separate
branch with <code>git stash branch newstuff</code>.
</div>


<h2 id="bitgit:git:fetch">Replacing pull by fetch and merge</h2>

<p>
The <code>git pull</code> command actually performs two steps that are sometimes
advantageous to run separately. First, a <code>get fetch</code> is run to fetch
new files from the repository, and thereafter a <code>git merge</code> command is
run to merge the new files with your local version of the files.
While <code>git pull</code> tries to do a lot and be smart in the merge, very
often with success, the merge step may occasionally lead to
trouble. That is why it is recommended to run a <code>git merge</code>
separately, especially if you work with branches.

<p>
To fetch files from your repository at GitHub, which usually has
the nickname <code>origin</code>, you write

<p>
<!-- begin verbatim block  sys-->
<pre><code>Terminal&gt; git fetch origin
</code></pre>
<!-- end verbatim block -->
You now have the possibility to check out in detail what the differences
are between the new files and local ones:

<p>
<!-- begin verbatim block  sys-->
<pre><code>Terminal&gt; git diff origin/master
</code></pre>
<!-- end verbatim block -->
This command produces comparisons of the files in the current local branch
and the <code>master</code> branch at <code>origin</code> (the GitHub repo).
In this way you can exactly see the differences between branches.
It also gives you an overview of what others have done with
the files.
When you are ready to merge in the new files from the <code>master</code> branch
of <code>origin</code> with the files in the current local branch, you say

<p>
<!-- begin verbatim block  sys-->
<pre><code>Terminal&gt; git merge origin/master
</code></pre>
<!-- end verbatim block -->

<p>
Especially when you work with multiple branches, as outlined in
the section <a href="#bitgit:git:branch:stash">Git working style with branching and stashing</a>, it is wise to first do a
<code>get fetch origin</code> and then update each branch separately. The
<code>git fetch origin</code> command will list the branches, e.g.,

<p>
<!-- begin verbatim block  sys-->
<pre><code>* master
  gh-pages
  next
</code></pre>
<!-- end verbatim block -->
After updating <code>master</code> as described, you can continue with another branch:

<p>
<!-- begin verbatim block  sys-->
<pre><code>Terminal&gt; git checkout next
Terminal&gt; git diff origin/next
Terminal&gt; git merge origin/next
Terminal&gt; git checkout master
</code></pre>
<!-- end verbatim block -->

<h3 id="___sec24">Configuring the <code>git diff</code> command </h3>

<p>
The <code>git diff</code> command launches by default the
Unix <code>diff</code> tool in the terminal window.
Many users prefer to use other diff tools, and the desired one
can be specified in
your <code>~/.gitconfig</code> file. However, a much recommended approach is to
wrap a shell script around the call to the diff program, because
<code>git diff</code> actually calls the diff program with a series of
command-line arguments that will confuse diff programs that take
the names of the two files to be compared as arguments.
In <code>~/.gitconfig</code> you specify a script to do the diff:

<p>
<!-- begin verbatim block -->
<pre><code>[diff]
external = ~/bin/git-diff-wrapper.sh
</code></pre>
<!-- end verbatim block -->
It remains to write the <code>git-diff-wrapper.sh</code> script.
The  2nd and 5th command-line arguments passed to this script are the
name of the files to be compared in the diff. A typical script may
therefore look like

<p>
<!-- begin verbatim block  shpro-->
<pre><code>#!/bin/sh

diff &quot;$2&quot; &quot;$5&quot; | less
</code></pre>
<!-- end verbatim block -->
Here we use the standard (and quite primitive) Unix <code>diff</code> program,
but we can replace <code>diff</code> by, e.g., <code>diffuse</code>, <code>kdiff3</code>, <code>xxdiff</code>, <code>meld</code>, <code>pdiff</code>, or others. With a Python script you can easily check
for the extensions of the files and use different diff tools for
different types of files, e.g., <code>latexdiff</code> for LaTeX files
and <code>pdiff</code> for pure text files.

<p>
<div class="alert alert-block alert-notice alert-text-normal">
<b>Replacing all your files with those in the repo.</b>
<p>
Occasionally it becomes desirable to replace <em>all</em> files in
the local repo with those in the repo at the file hosting service.
One possibility is removing your repo and cloning again, or
use the Git commands

<p>
<!-- begin verbatim block  sys-->
<pre><code>Terminal&gt; git fetch --all
Terminal&gt; git reset --hard origin/master
</code></pre>
<!-- end verbatim block -->
</div>


<p>
<div class="alert alert-block alert-notice alert-text-normal">
<b>Merging with just one file from another branch.</b>
<p>
Say you have two branches, A and B, and want to merge a file <code>f.txt</code>
in A with the latest version in B. To merge this single file, go to
the directory where <code>f.txt</code> resides and do

<p>
<!-- begin verbatim block  sys-->
<pre><code>Terminal&gt; git checkout A
Terminal&gt; git checkout --patch B f.txt
</code></pre>
<!-- end verbatim block -->

<p>
If <code>f.txt</code> is not present in branch A, and if you want to include more
files, drop the <code>--patch</code> option and specify files with full path relative
to the root in the repo:

<p>
<!-- begin verbatim block  sys-->
<pre><code>Terminal&gt; git checkout A
Terminal&gt; git checkout B doc/f.txt src/files/g.py
</code></pre>
<!-- end verbatim block -->
Now, <code>f.txt</code> and <code>g.py</code> from branch B will be included in branch A as well.
</div>


<h2 id="bitgit:git:team">Team work with forking and pull requests</h2>

<p>
In small collaboration teams it is natural that everyone has push access
to the repo. On GitHub this is known as the <em>Shared Repository Model</em>.
As teams grow larger, there will usually be a few
people in charge who should approve changes to the files. Ordinary team members
will in this case not clone a repo and push changes, but instead
<em>fork</em> the repo and send <em>pull requests</em>, which constitutes the
<em>Fork and Pull Model</em>.

<p>
Say you want to fork the repo <code>https://github.com/somebody/proj1.git</code>.
The first step is to press the <em>Fork</em> button on the project page for
the <code>somebody/proj1</code> project on GitHub.
This action creates a new repo <code>proj1</code>, known as the forked repo,
on your GitHub account.
Clone the fork as you clone any repo:

<p>
<!-- begin verbatim block  sys-->
<pre><code>Terminal&gt; git clone https://github.com/user/proj1.git
</code></pre>
<!-- end verbatim block -->
When you do <code>git push origin master</code>, you update your fork.
However, the original
repo is usually under development too, and you need to pull from that
one to stay up to date. A <code>git pull origin master</code> pulls from
<code>origin</code> which is your fork. To pull from the original repo, you
create a name <code>upstream</code>, either by

<p>
<!-- begin verbatim block  sys-->
<pre><code>Terminal&gt; git remote add upstream \
              https://github.com/somebody/proj1.git
</code></pre>
<!-- end verbatim block -->
if you cloned with such an <code>https</code> address, or by

<p>
<!-- begin verbatim block  sys-->
<pre><code>Terminal&gt; git remote add upstream \
              git@github.com:somebody/proj1.git
</code></pre>
<!-- end verbatim block -->
if you cloned with a <code>git@github.com</code> (SSH) address.
Doing a <code>git pull upstream master</code> would seem to be the command for
pulling the most recent files in
the original repo. However,
it is not recommended to update the forked repo's files this way
because heavy development of the <code>sombody/proj1</code> project may
lead to serious merge problems.
It is much better to replace the pull by a separate
<em>fetch</em> and <em>merge</em>.
The typical workflow is

<p>
<!-- begin verbatim block  sys-->
<pre><code>Terminal&gt; git fetch upstream           # get new version of files
Terminal&gt; git merge upstream/master    # merge with yours
Terminal&gt; # Your files are up to date - ready for editing
Terminal&gt; git commit -am 'Description...'
Terminal&gt; git push origin master       # store changes in your fork
</code></pre>
<!-- end verbatim block -->

<p>
At some point you would like to push your changes back to the original
repo <code>somebody/proj1</code>. This is done by a <a href="https://help.github.com/articles/using-pull-requests" target="_self">pull request</a>. Make sure you
have selected the right branch on the project page of your forked
project. Press the <em>Pull Request</em> button and fill out the form that
pops up.  Trusted people in the <code>somebody/proj1</code> project will now
review your changes and if they are approved, your files are merged
into the original repo. If not, there are tools for keeping a dialog
about how to proceed.

<p>
Also in small teams where everyone has push access, the fork and pull
request model is beneficial for reviewing files before the repo
is actually updated with new contributions.

<h2 id="bitgit:git:clone:branches">Cloning a repo with multiple branches</h2>

<p>
An annoying feature of Git for beginners is the fact that if you
clone a repo, you only get the <code>master</code> branch. There are seemingly
no other branches:

<p>
<!-- begin verbatim block  sys-->
<pre><code>Terminal&gt; git branch
* master
</code></pre>
<!-- end verbatim block -->
To see which branches that exist in the repo, type

<p>
<!-- begin verbatim block  sys-->
<pre><code>Terminal&gt; git branch -a
* master
  remotes/origin/HEAD -&gt; origin/master
  remotes/origin/gh-pages
  remotes/origin/master
  remotes/origin/next
</code></pre>
<!-- end verbatim block -->
If there is only one remote repo that
you pull/push from/to, you can simply switch branch with <code>git checkout</code>
the usual way:

<p>
<!-- begin verbatim block  sys-->
<pre><code>Terminal&gt; git checkout gh-pages
Terminal&gt; git branch
* gh-pages
  master
Terminal&gt; git checkout next
Terminal&gt; git branch
  gh-pages
  master
* next
</code></pre>
<!-- end verbatim block -->
You might need to do <code>git fetch origin</code> to see new branches made
on other machines.

<p>
When you have more than one remote, which is usually the case if you have
forked a repo, see the section <a href="#bitgit:git:team">Team work with forking and pull requests</a>, you must use do a
checkout with specifying the remote branch you want:

<p>
<!-- begin verbatim block  sys-->
<pre><code>Terminal&gt; git checkout -b gh-pages --track remote/gh-pages
Terminal&gt; git checkout -b next --track upstream/next
</code></pre>
<!-- end verbatim block -->
Files can be edited, added, or removed as soon as you have done
the local checkout.

<p>
It is possible to write a little script that takes the output of
<code>git branch -a</code> after a <code>git clone</code> command and automatically check
out all branches via <code>git checkout</code>.

<h2 id="___sec27">Git workflows </h2>

<p>
Although the purpose of these notes is just to get the reader started
with Git, it must be mentioned that there are advanced features of Git
that have led to very powerful workflows with files and people,
especially for software development.  There is an official <a href="https://www.kernel.org/pub/software/scm/git/docs/gitworkflows.html" target="_self">Git
workflow model</a>
that outlines the basic principles, but it can be quite advanced for
those with modest Git knowledge.  A more detailed explanation of a
recommended workflow for beginners is given in the <a href="https://bitbucket.org/petsc/petsc/wiki/developer-instructions-git" target="_self">developer
instructions</a>
for the software package PETSc. This is highly suggested reading.  The
associated "quick summary" of Git commands for their workflow is also
useful.

<p>
<!-- Make a case with computer code and a latex document -->
<!-- get fetch origin, git diff to see what, git blame and so on -->
<!-- Have a scripted flow of changes, do a rewrite in a new branch, -->
<!-- another do software developments in a new branch, merge back, -->
<!-- use dolfin workflow as model, but in a real-life case. -->
<!-- Can make movie by having two users, one in Mac, one in Ubuntu, -->
<!-- and switch back and forth to explain what is done. Write the -->
<!-- script with such a video in mind. This is something I can play -->
<!-- live too (for biocomp seminars also: Git workflows beyond -->
<!-- heavy software development, could also be a blog, suggestions -->
<!-- for student work, thesis work, cinpla, etc.). Could think of -->
<!-- doconce source and then the collaborator edits the .tex file, -->
<!-- it is overwritten, what do to. Or that could be a later chapter -->
<!-- of the whole theater. Divide things into chapters: setting -->
<!-- up the repo, John and Paul work, make short initial files. -->
<!-- Or maybe markdown instead of doconce? Filter to latex... -->
<!-- Software: random walk which writes all steps to file and -->
<!-- generates a lot of data we won't have in the repo. Or wave1D, -->
<!-- then it's easier to write the report...and all solutions can -->
<!-- be written to file :-) at some stage the report should be -->
<!-- be large (just copy a ready-made larger report in the script). -->
<!-- The script can checkout two directories and just switch between -->
<!-- these as two users, don't need to be different machines... -->

<h2 id="___sec28">Git tips </h2>

<h3 id="___sec29">How can I see which files are tracked by Git? </h3>

<p>
<code>git ls-files</code> is the command:

<p>
<!-- begin verbatim block  sys-->
<pre><code>Terminal&gt; git ls-files            # list all tracked files
Terminal&gt; git ls-files -o         # list non-tracked files
Terminal&gt; git ls-files myfile     # prints myfile if it's tracked
Terminal&gt; git ls-files myfile --error-unmatch
</code></pre>
<!-- end verbatim block -->
The latter command prints an error message if <code>myfile</code> is not tracked.
See <code>man git-ls-files</code> for the many options this utility has.

<h3 id="___sec30">How can I reduce the size of a repo? </h3>

<p>
The command <code>git gc</code> can compress a git repository and should be
run regularly on large repositories. Greater effect
is achieved by <code>git gc --aggressive --prune=all</code>. You can measure the
size of a repo before and after compression by <code>git gc</code> using
<code>du -s repodir</code>, where <code>repodir</code> is the name of the root directory of
the repository.

<p>
Occasionally big or sensitive files are removed from the repo and you want to
permanently remove these files from the revision history. This is
achieved using <a href="https://help.github.com/articles/remove-sensitive-data" target="_self"><tt>git filter-branch</tt></a>. To remove a file or directory with path <code>doc/src/mydoc</code> relative to the root directory of the repo, go to this root directory, make sure all branches are checked out on your computer, and run

<p>
<!-- begin verbatim block  sys-->
<pre><code>Terminal&gt; git filter-branch --index-filter \
         'git rm -r --cached --ignore-unmatch doc/src/mydoc' \
         --prune-empty -- --all
Terminal&gt; rm -rf .git/refs/original/
Terminal&gt; git reflog expire --expire=now --all
Terminal&gt; git gc --aggressive --prune=now
Terminal&gt; git push origin master --force  # do this for each branch
Terminal&gt; git checkout somebranch
Terminal&gt; git push origin somebranch --force
</code></pre>
<!-- end verbatim block -->
You must repeat the <code>push</code> command for each branch as indicated.
If other users have created their own branches in this repo, they
need to <a href="http://git-scm.com/book/en/Git-Branching-Rebasing" target="_self"><tt>rebase</tt></a>,
not <code>merge</code>, when updating the branches!

<h3 id="___sec31">How can I restore missing files? </h3>

<p>
Sometimes you accidentally remove files from a repo, either by <code>git rm</code> or
a plain <code>rm</code>. You can get the files back as long as they are in the remote
repo. In case of a plain <code>rm</code> command, run

<p>
<!-- begin verbatim block  sys-->
<pre><code>Terminal&gt; git checkout `git ls-files`
</code></pre>
<!-- end verbatim block -->
to restore all missing files in the current directory.

<p>
In case of a <code>git rm</code> command, use
<code>git log --diff-filter=D --summary</code> to find the commit hash
corresponding to the last commit
the files were in the repo. Restoring a file is then done by

<p>
<!-- begin verbatim block  sys-->
<pre><code>Terminal&gt; git checkout &lt;commit hash&gt; filename
</code></pre>
<!-- end verbatim block -->

<h2 id="___sec32">More documentation on Git </h2>

<ul>
 <li> <a href="http://rogerdudler.github.io/git-guide/" target="_self">Git - the simple guide</a></li>
 <li> <a href="http://try.github.com/" target="_self">Web course on Git</a></li>
 <li> <a href="http://schacon.github.com/git/everyday.html" target="_self">Everyday GIT With 20 Commands Or So</a></li>
 <li> <a href="http://www.ndpsoftware.com/git-cheatsheet.html" target="_self">Git cheat sheet</a></li>
 <li> <a href="https://www.atlassian.com/git/tutorial/git-basics" target="_self">Atlassian Git Tutorials</a></li>
 <li> <a href="https://www.atlassian.com/git/tutorial/workflows" target="_self">Atlassian Git Workflows</a></li>
 <li> GitHub Guides:</li>

<ul>
  <li> <a href="https://guides.github.com/introduction/getting-your-project-on-github/" target="_self">Getting your project on GitHub</a></li>
  <li> <a href="https://guides.github.com/activities/hello-world/" target="_self">Repositories, branches, commits, issues, and pull requests</a></li>
  <li> <a href="https://guides.github.com/features/pages/" target="_self">GitHub (web) pages</a></li>
  <li> <a href="https://guides.github.com/introduction/flow/" target="_self">Understanding the GitHub Flow</a></li>
</ul>

 <li> <a href="http://pcottle.github.io/learnGitBranching/" target="_self">Git branching</a></li>
 <li> <a href="http://sixrevisions.com/resources/git-tutorials-beginners/" target="_self">Git top 10 tutorials</a></li>
 <li> <a href="http://www.vogella.com/articles/Git/article.html" target="_self">Lars Vogel's Git Tutorial</a></li>
 <li> <a href="http://jetheis.com/blog/2013/02/17/using-dropbox-as-a-private-github/" target="_self">How to use Git with Dropbox</a></li>
 <li> <a href="http://book.git-scm.com/" target="_self">Git Community Book</a> (<em>explains</em> Git very well)</li>
 <li> <a href="http://hoth.entp.com/output/git_for_designers.html" target="_self">Git for Designers</a> (aimed a people with no previous knowledge of version control systems)</li>
 <li> <a href="http://www-cs-students.stanford.edu/~blynn/gitmagic/ch02.html" target="_self">Git Magic: Basic Tricks</a></li>
 <li> The official <a href="http://schacon.github.com/git/gittutorial.html" target="_self">Git Tutorial</a></li>
 <li> <a href="http://www.youtube.com/watch?v=TPY8UwlTIc0&feature=related" target="_self">Git Tutorial Video</a> on YouTube</li>
 <li> <a href="http://wiki.sourcemage.org/Git_Guide" target="_self">Git Questions</a></li>
 <li> <a href="http://gitref.org" target="_self">Git Reference</a> (can also be used as a tutorial on Git)</li>
 <li> <a href="http://schacon.github.com/git/user-manual.html" target="_self">Git User Manual</a></li>
 <li> <a href="http://git-scm.com/" target="_self">Git home page</a></li>
 <li> <a href="http://www.classes.cs.uchicago.edu/archive/2013/spring/12300-1/labs/lab1/" target="_self">Quick intro to Git and GitHub</a> (somewhat like the present guide)</li>
 <li> <a href="http://git-scm.com/downloads/guis" target="_self">Git/GitHub GUIs on Windows and Mac</a></li>
 <li> <a href="http://steveko.wordpress.com/2012/02/24/10-things-i-hate-about-git/" target="_self">10 Things I hate about Git</a></li>
</ul>

<!-- !split -->

<h1 id="appendix:github:multiple:accounts">Appendix: Working with multiple GitHub accounts</h1>

<p>
Working against different GitHub accounts is easy if each project you work
with on each account adds you as a collaborator. The term "you" here means your
primary username on GitHub. My strong recommendation is to always check
out a project
using your primary GitHub username.

<p>
Occasionally you want to create a new GitHub account, say for a project <code>XYZ</code>.
For such a non-personal account, do <em>not</em> provide an SSH key of any
particular user. The reason is that this user will then get two
GitHub identities, and switching between these identities will require
some special tweakings. Just forget about the SSH key for a project
account and add
collaborators to repos using each collaborators personal GitHub username.

<p>
If you really need to operate the <code>XYZ</code> account as a
personal account, you must provide an SSH key that is different from
any other key at any other GitHub account (you will get an error message
if you try to register an already registered SSH key, but it is possible to
get around the error message by providing
an <code>id_rsa.pub</code> key on one account and an <code>id_dsa.pub</code> on another - that
will cause trouble). Jeffrey Way has written a recipe for <a href="http://net.tutsplus.com/tutorials/tools-and-tips/how-to-work-with-github-and-multiple-accounts/" target="_self">how to operate multiple GitHub accounts
using multiple identities</a>.

<p>
To debug which identity that is used when you pull and push to
GitHub accounts, you can first run
<!-- begin verbatim block  sys-->
<pre><code>Terminal&gt; ssh -Tv git@github.com
</code></pre>
<!-- end verbatim block -->
to see your current identity and which SSH key that was used to identify you.
Typing
<!-- begin verbatim block  sys-->
<pre><code>Terminal&gt; ssh-add -l
</code></pre>
<!-- end verbatim block -->
lists all your SSH keys. The shown strings can be compared with the
string in the SSH key field of any GitHub account.

<!-- ------------------- end of main content --------------- -->


<center style="font-size:80%">
<!-- copyright --> &copy; 2015, Hans Petter Langtangen. Released under CC Attribution 4.0 license
</center>


</body>
</html>
    

