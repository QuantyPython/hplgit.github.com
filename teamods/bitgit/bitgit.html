<?xml version="1.0" encoding="utf-8" ?>
<!--
Automatically generated HTML file from Doconce source
(http://code.google.com/p/doconce/)
-->

<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Doconce: http://code.google.com/p/doconce/" />
</head>

<body bgcolor="white">
    <title>Quick Intro to Version Control Systems and Project Hosting Services</title>
<center><h1>Quick Intro to Version Control Systems and Project Hosting Services</h1></center>
<center>
<b>Hans Petter Langtangen</b> [1, 2]
</center>

<p>
<center>[1] <b>Center for Biomedical Computing, Simula Research Laboratory,</b></center>
<center>[2] <b>Deptartment of Informatics, University of Oslo</b></center>


<center><h3>Mar 6, 2012</h3></center>
<P>
<a name="bitgit:top"></A>

<P>
Version control systems allow you to record the history of files
and share files among several computers and collaborators in a
professional way. File changes on one computer are updated or
merged with changes on another computer. Especially when working
with programs or technical reports it is essential
to have changes documented and to
ensure that every computer and person involved in the project
have the latest updates of the files.
Greg Wilson' excellent <a href="http://software-carpentry.org/2010/07/script-for-introduction-to-version-control/">Script for Introduction to Version Control</a> provides a more detailed motivation why you will benefit greatly
from using version control systems.

<P>
Projects that you want to share among several computers or project
workers are today most conveniently stored at some web site "in the
cloud" and updated through communication with that site. I strongly
recommend you to use such sites for all serious programming and
scientific writing work -- and all other important files.

<P>
The simplest services for hosting project files is Dropbox. Simply
go to <a href="http://dropbox.com"><tt>http://dropbox.com</tt></a> and watch the video. It is very easy to get
started with Dropbox, and it allows you to share files among
laptops and mobile units.

<P>
When several people may edit files simultaneously, it can be
difficult detect who did what when, roll back to previous versions,
and to manually merge the edits when these are incompatible. Then ones needs
more sophisticated tools than Dropbox:
project hosting services with true version control systems.
This is what we aim at getting you started with here.

<P>
The idea with project hosting services is that you have the files
associated with a project in the cloud. Many people may share these
files.  Every time you want to work on the project you explicitly
update your version of the files, edit the files as you like, and
synchronize the files with the "master version" at the site where the
project is hosted.  If you at some point need to go back to the
version of the files at some particular you when you known everything
was fine, this is an easy operation. You can also use tools to see
what various people (or just yourself) have done with the files.

<P>
Four popular project hosting services are

<P>

<ul>
  <li> Bitbucket at <tt>bitbucket.org</tt>
  <li> GitHub at <tt>github.com</tt>
  <li> Googlecode at <tt>code.google.com</tt>
  <li> Launchpad at <tt>launchpad.net</tt>
</ul>

All these services are very similar. Here we describe how you get
started with Bitbucket, GitHub, and Googlecode. All the project
hosting services have good introductions
available at their web sites, but the recipes below aim at getting you
started even quicker through a specific example.
Launchpad works very similarly to Bitbucket, GitHub, and Googlecode.

<P>
The mention services host all your files in a specific project in what
is known as a <em>repository</em>, or <em>repo</em> for short.  When a copy of the
files are wanted on a certain computer, one clones the repository on
that computer.  This creates a local copy of the files. Now files can
be edited, new ones can be added, and files can be deleted.  These
changes are then brought back to the repository.  If users at
different computers synchronize their files frequently with the
repository, most modern version control systems will be able to merge
changes in files that have been edited simultaneously on different
computers. This is perhaps one of the most useful features of project
hosting services.

<P>
<!-- Next we describe how to get started with Bitbucket and GitHub.  If you -->
<!-- are new to project hosting sites, it is recommended to read about -->
<!-- Bitbucket first, since the description of GitHub is briefer. -->

<P>
For the examples below, assume that you have some directory tree
<tt>my-project</tt> with files that you want to host at Bitbucket, GitHub, or
Googlecode and bring under version control. The official name of the
project is "My Project".

<P>
<h2>Installing Version Control Systems</h2>
<P>
The various project hosting sites work with different version
control systems:

<P>

<ul>
 <li> <tt>bitbucket.org</tt> offers Git (<tt>git</tt>) or Mercurial (<tt>hg</tt>),
 <li> <tt>github.com</tt> offers Git (<tt>git</tt>),
 <li> <tt>code.google.com</tt> offers Git (<tt>git</tt>), Mercurial (<tt>hg</tt>), or Subversion (<tt>svn</tt>),
 <li> <tt>launchpad.net</tt> offers Bazaar (<tt>bzr</tt>).
</ul>

All the version control systems are quite similar in the way users
operate them, but Subversion is technically different from Git,
Mercurial, and Bazaar. The latter three work very much in the same way
for a beginner, but their more advanced commands and their
nomenclature differ significantly.  Which system to choose is mainly a
matter of personal preference and experience. For some people the
choice of project hosting site comes first, while others prefer a
particular version control system and let this preference govern the
choice of project hosting site.

<P>
It is possible to use Mercurial also with a GitHub project. This
requires a plugin for Mercurial, described in <a href="http://hg-git.github.com"><tt>http://hg-git.github.com</tt></a>.
The plugin is easy to install (<tt>easy-install hg-git</tt> or
<tt>sudo apt-get install mercurial-git</tt> on Ubuntu). You can also use
Git to work with Subversion and Mercurial repositories.

<P>
The author's experience from teaching contexts points to the combination
of Bitbucket and Mercurial is the simplest to get started with,
foremost because it appears that Mercurial is easier to learn than Git
beyond the very basic commands.
The
combination of GitHub and Git seems to have the strongest momentum and
popularity in the software development community at the time of this
writing.

<P>
<h3>Installing Mercurial</h3>
<P>

<P>
The <a href="http://mercurial.selenic.com/">Mercurial website</a> has information
on downloading Mercurial on different platforms.
On Ubuntu, you just perform
<blockquote>    <!-- begin verbatim block   sys-->
<pre>
sudo apt-get install mercurial
</pre>
</blockquote>   <! -- end verbatim block -->
You can alternatively click in the Synaptic Package
Manager and choose the Mercurial package in the graphical interface.

<P>
Mercurial is pure Python code so it is trivial on any system with Python
installed to download the Mercurial source code and perform
the standard <tt>sudo python setup.py install</tt> command.

<P>
You need to create two files in your home directory: <tt>.hgrc</tt> for
specifying the behavior of <tt>hg</tt> (Mercurial) and <tt>.hgignore</tt> for
listing the type of files you in general do not want to have under version
control. A simple <tt>.hgrc</tt> file can look like this:
<blockquote>    <!-- begin verbatim block   dat-->
<pre>
[ui]
username = "Hans Petter Langtangen &lt;hpl@simula.no&gt;"
ignore=~/.hgignore
</pre>
</blockquote>   <! -- end verbatim block -->
The <tt>.hgignore</tt> file lists the types of files that will be skipped
when bringing new directories under Mercurial version control.
Typically this is temporary files sich as object files (<tt>*.o</tt>),
shared libraries (<tt>*.so</tt>), and backup files (<tt>*.bak</tt> and <tt>*~</tt>).
The file types are usually specified using Unix Shell Wildcard notation,
also referred to as <tt>glob</tt> syntax, as in <tt>*.o</tt> (where <tt>*</tt> means any
sequence of characters).
An example of a <tt>.hgignore</tt> file may be
<blockquote>    <!-- begin verbatim block   dat-->
<pre>
syntax: glob
*.o
*.so
*.a
*~
.*~
*.log
*.dvi
*.aux
*.old
*.bak
tmp*
</pre>
</blockquote>   <! -- end verbatim block -->

<P>

<P>

<P>
<h3>Installing Git</h3>
<P>

<P>
The installation of Git on various systems is described
on the <a href="http://git-scm.com/">Git website</a> under the <em>Download</em> section.
On Ubuntu the relevant commands are
<blockquote>    <!-- begin verbatim block   sys-->
<pre>
sudo apt-get install git gitk git-doc
</pre>
</blockquote>   <! -- end verbatim block -->
Git involves compiled code so it is most convenient to download a
precompiled binary version of the software on Windows, Mac and other
Linux computers.

<P>
Make a file <tt>.gitconfig</tt> in your home directory with information on
your full name, email address, your favorite emacs editor, and
the name of a file which defines the file types that Git should omit
when bringing new directories under version control.
Here is a simplified version of the author's <tt>.gitconfig</tt> file:
<blockquote>    <!-- begin verbatim block   dat-->
<pre>
[user]
name = Hans Petter Langtangen
email = hpl@simula.no
editor = emacs

[core]
excludesfile = ~/.gitignore
</pre>
</blockquote>   <! -- end verbatim block -->

<P>
The <tt>.gitignore</tt> file should list, using the Unix Shell Wildcard notation,
the type of files that you do not want to have under version control,
typically (large) files that can easily be regenerated from some other
source files. A <tt>.gitignore</tt> file may look like
<blockquote>    <!-- begin verbatim block   dat-->
<pre>
*.o
*.so
*.a
*~
.*~
*.log
*.dvi
*.aux
*.old
*.bak
tmp*
</pre>
</blockquote>   <! -- end verbatim block -->

<P>

<P>
<h2>Bitbucket <a name="bitgit:bitbucket"></A></h2>
<P>

<P>

<P>
To start using Bitbucket, go to <tt>bitbucket.org</tt> and create an account.
My favorite communication channel with Bitbucket repositories is
through SSH and HTTPS as used in their examples.  To use SSH, you must
upload your SSH key, typically the contents of the file <tt>id_rsa.pub</tt>
or <tt>id_dsa.pub</tt> in the <tt>.ssh</tt> subdirectory of your home directory. Go
to the page for your account and upload one of these files. If you do
not have any of them, click on the link "Using SSH", which explains
what you need to know.

<P>
<h3>Create a New Project</h3>
<P>
Click at <tt>Repositories</tt> and at <tt>create repository</tt>.
You can now

<P>

<ul>
 <li> fill in the name of the project, here <tt>my-project</tt>,
 <li> choose between the Git or Mercurial version control system,
 <li> decide whether the project is private or public (the number of
   private repos for a user is limited unless you pay),
 <li> click whether you want issue tracking for reporting errors,
   suggesting improvements, etc.,
 <li> click whether you want a wiki page associated witht the project.
</ul>

You may also want to have the <a href="http://confluence.atlassian.com/display/BITBUCKET/Bitbucket+101">Bitbucket 101 guide</a>
available (open the link in another tab or window in your browser).

<P>
It is now time to copy the project to your laptop, or <em>clone</em> it
in Git and Mercurial terminology. Go to the project page
and find the <em>Clone this repository</em> line. Click on <em>SSH</em>,
copy the <em>clone</em> line and run this command in a terminal:
<blockquote>    <!-- begin verbatim block   sys-->
<pre>
hg clone ssh://hg@bitbucket.org/username/my-project
# or
git clone ssh://hg@bitbucket.org/username/my-project.git
</pre>
</blockquote>   <! -- end verbatim block -->
Only the <tt>hg</tt> or the <tt>git</tt> command is display since your project was
initialized with either Merucial or Git as version control system (this
cannot be changed later).
In the above command you must replace <tt>username</tt> by your own user name
at Bitbucket.

<P>
The next step is to collect files and directories that should make up
the project and put them in the <tt>my-project</tt> directory.

<P>
Then all files should be brought under version control, with the exception
of the file types listed in <tt>.hgignore</tt>.
Issue the following command in the <tt>my-project</tt> directory:
<blockquote>    <!-- begin verbatim block   sys-->
<pre>
hg add
# or
git add .
</pre>
</blockquote>   <! -- end verbatim block -->

<P>
Thereafter, the changes to the repository (adding of files) must
be registered, or <em>commited</em> if we use standard version control system
terminology. The command reads
<blockquote>    <!-- begin verbatim block   sys-->
<pre>
hg commit  -m 'Initial import of files.'
# or
git commit -m 'Initial import of files.'
</pre>
</blockquote>   <! -- end verbatim block -->
The <tt>-m</tt> option is a required description of the changes that have taken
place. This description does not matter much for this initial import
of files into the repository, but is of importance for future commit
commands such that you can easily track the history of your project files.

<P>
The final step is to push the local changes to the master repo at
Bitbucket:
perform
<blockquote>    <!-- begin verbatim block   sys-->
<pre>
hg push
# or
git push -u origin master
</pre>
</blockquote>   <! -- end verbatim block -->
You must be connected to the Internet for the <tt>push</tt> command to work since
it sends file information to the <tt>bitbucket.org</tt> site.

<P>
Further work with the files must always follow the pull, edit, commit, and
push steps explained in the section <a href="#bitgit:hg">Using Mercurial</a> for Mercurial and
Section {bitgit:git} for Git.

<P>
<h2>Googlecode <a name="bitgit:googlecode"></A></h2>
<P>

<P>

<P>
To use Googlecode you need a general account on Google.

<P>

<P>
<h3>Create a New Project</h3>
<P>
Go to <a href="http://code.google.com/hosting"><tt>http://code.google.com/hosting</tt></a> and click on
<em>Create a new project</em>. Fill out <em>all</em> the fields. For now
the project name is <tt>my-project</tt>.
You have
to choose between Git, Mercurial, and Subversion as version control
system for your project, and this choice cannot be changed.
Git and Mercurial are preferred over Subversion nowadays.
If you choose Git, you must create a file <tt>.netrc</tt> in your
home directory containing the line
<blockquote>    <!-- begin verbatim block   dat-->
<pre>
machine code.google.com login uname password pw
</pre>
</blockquote>   <! -- end verbatim block -->
Here, <tt>uname</tt> is your user name for the Google account and
<tt>pw</tt> is the Googlecode password which is generated for you on
the <tt>code.google.com/p/my-project</tt>.
The <tt>.netrc</tt> file avoids typing or pasting in
your long and complicated password every time you push changes to
the repository on <tt>code.google.com</tt>.

<P>
The next step is to clone the empty repository on your local machine
so that you can add files:
<blockquote>    <!-- begin verbatim block   sys-->
<pre>
git clone https://code.google.com/p/my-project/
</pre>
</blockquote>   <! -- end verbatim block -->
Now you can go to the <tt>my-project</tt> directory and add files.
Perform
<blockquote>    <!-- begin verbatim block   sys-->
<pre>
git add .
git commit am 'First import of files.'
git push origin master
</pre>
</blockquote>   <! -- end verbatim block -->
Click on <em>Source</em> and
<em>Browse</em> on the project's web page, and realize that the added
files are visible on the project page.

<P>
If you use Mercurial as version control system on Googlecode and
you want to avoid giving your password when you push changes to
the repository, you should add the following section to your
<tt>.hgrc</tt> file:
<blockquote>    <!-- begin verbatim block   dat-->
<pre>
[auth]
my-project.prefix = https://my-project.googlecode.com/hg/
my-project.username = uname
my-project.password = pw
</pre>
</blockquote>   <! -- end verbatim block -->
where <tt>uname</tt> and <tt>pw</tt> must be replaced by your account name and
the special Googlecode password. Other projects on Googlecode
using Mercurial will need similar lines.

<P>
A very strong and useful feature with Googlecode, in my opinion, is
that one can reach the repository files directly through an URL.
That means that one can place documentation of the project in
the repository and find an URL to the HTML or PDF files of the documentation,
which will then be displayed correctly. All other project hosting sites
demands either wiki pages or special web areas for locating documentation.
The URL to your files is
<blockquote>    <!-- begin verbatim block   dat-->
<pre>
https://my-project.googlecode.com/git/
</pre>
</blockquote>   <! -- end verbatim block -->
When using other version control systems, <tt>git</tt> is simply replaced by
<tt>hg</tt> or or <tt>svn</tt>.
For example, if we have HTML documentation of our project in
the directory <tt>doc/API/html</tt>, we can point users to
<blockquote>    <!-- begin verbatim block   dat-->
<pre>
https://my-project.googlecode.com/git/doc/API/html/index.html
</pre>
</blockquote>   <! -- end verbatim block -->
The HTML will be rendered correctly as opposed to when you load
the similar file into the web browser from the repository,
<blockquote>    <!-- begin verbatim block   dat-->
<pre>
http://code.google.com/p/my-project/source/browse/doc/API/html/index.html
</pre>
</blockquote>   <! -- end verbatim block -->
Now you can only see the HTML source code of this file, as is usual
on other project hosting sites.

<P>
You can click on <em>Project Home</em> and then on <em>Administer</em> to edit the
main page of the project. This is a wiki, using Google's wiki syntax,
but it is quite easy to add links to your documentation, e.g.,
<blockquote>    <!-- begin verbatim block   dat-->
<pre>
Browse the
[https://my-project.googlecode.com/git/doc/API/html/index.html
API documentation].
</pre>
</blockquote>   <! -- end verbatim block -->

<P>
It is easy to allow others to push their changes to the
repository: click on <em>Sharing</em> and then on <em>Administer</em>.
The Google account names of people you allow write access can be
listed under each other in the <em>Project committers</em> field.

<P>
<h3>Wiki Pages</h3>
<P>
Wiki pages can intuitively be made directly in the browser. However,
it is often more convenient to have them locally on your computer.
Click on <em>Source</em> and choose <em>wiki</em> on the <em>Repository</em> pull down menu.
The proper clone command to get a copy of the wiki repository then
appears.

<P>
Googlecode applies their own Google wiki format. My preference is
to write documentation in the neutral <a href="http://code.google.com/p/doconce">Doconce</a> format and transform the document to LaTeX, Sphinx, and Google wiki.
The wiki can then be copied from the project directories to the
wiki directory and then pushed to the repository. This ensures
that there is only one source of the documentation (despite the need
for many formats) and that the wiki pages are frequently updated.

<P>
<!-- https://odespy.googlecode.com/git/doc/API/index.html -->
<!-- https://odespy.googlecode.com/git/doc/tutorial/html/wrap_odesolvers.html -->

<P>

<P>
<h2>GitHub <a name="bitgit:github"></A></h2>
<P>

<P>

<P>

<P>
Go to <tt>github.com</tt> and create an account. Then
go to your account settings, choose <em>SSH Public Keys</em>, and provide
your SSH key. Everyone who is supposed to use your repository must
provide their SSH key.  There is a help that explains what this is all
about. Often, it is just a matter of pasting the contents of
<tt>id_rsa.pub</tt> or <tt>id_dsa.pub</tt> in the <tt>.ssh</tt> subdirectory of your home
directory into the <em>Key</em> box in the web page. Make sure to cut and
paste the text from, e.g., <tt>id_dsa.pub</tt> without any extra whitespaces
or other text.

<P>
A next step is to provide your so called API Token. Go to your account
settings and choose <em>Account Admin</em>, copy the API Token and place
it in the <tt>~/.gitconfig</tt> file like this
<blockquote>    <!-- begin verbatim block   dat-->
<pre>
[github]
token = 4b17350d7ea9d9xse4c98749a89fc15dfc4
</pre>
</blockquote>   <! -- end verbatim block -->

<P>
<h3>Create a New Project</h3>
<P>
Click on <em>New Repository</em> on the main page and fill out a project
name, here <em>My Project</em>.
Then create your project directory, here named <tt>My-Project</tt>,
on your computer and initialize the project:
<blockquote>    <!-- begin verbatim block   sys-->
<pre>
mkdir My-Project
cd My-Project
git init
touch README
git add README
git commit -m 'First import of files.'
</pre>
</blockquote>   <! -- end verbatim block -->
These commands initialize a local repository.
The next step is to copy all files that you want to have
has part of the project and
add them to Git by the command
<blockquote>    <!-- begin verbatim block   sys-->
<pre>
git add .
git commit -m 'Adding more files.'
</pre>
</blockquote>   <! -- end verbatim block -->
Create a remote name (usually <tt>origin</tt>)
for your repository at GitHub and push your local files to
the global repository:
<blockquote>    <!-- begin verbatim block   sys-->
<pre>
git remote add origin git@github.com:username/My-Project.git
git push -u origin master
</pre>
</blockquote>   <! -- end verbatim block -->
Make sure you replace <tt>username</tt> by your real username at GitHub.
Also note that when your project was registered with the name
"My Project", <tt>My-Project.git</tt> is the name you should use in the
<tt>git remote</tt> command (spaces in the project name on GitHub are replaced
by dashes in the similar directory name).

<P>
Find your new project on your personal <tt>github.com</tt> pages and check
that the project files you added are viewable on the web pages.

<P>

<P>
To give others permissions to push their edits of files to the
repository, you go to the project's page on <tt>github.com</tt>,
click on <em>Admin</em>, click on <em>Collaborators</em> on the left, and
fill in the name of a collaborator (her or his user name on GitHub).
You can click on <em>Service Hooks</em> and then <em>Email</em> in the list
to make each <tt>git commit</tt> command send an email to yourself or
others.

<P>
The daily file operations are explained in Section {bitgit:git}.
There you also find information on how to create wiki pages and
web pages associated with the project.

<P>

<P>
<h3>Wiki Pages</h3>
<P>
With every GitHub project there is an option to create wiki pages.
Click on the <em>Wiki</em> button right under the line with the project
name of the main page of the project. Click on <em>New Page</em> to create
a new page. The wiki pages can be written in different markup
languages. Markdown is the default choice, but you can alternatively
use reStructuredText (unfortunately not the Sphinx extension
with nice LaTeX mathematics) or MediaWiki (the markup used for
Wikipedia).

<P>
The wiki pages can be written and maintained through the web browser
interface, but it is usually more convenient to clone them on
your computer as this makes it easy to add figures and other documents
you may want to link to. It also makes it straightforward to edit
the wiki text in your favorit text editor. The wiki pages are
stored in a separate repo: click on <em>Git Access</em> and then on
<em>Git Read-Only</em> to see the
Git address for a standard <tt>git clone</tt> command, typically
<blockquote>    <!-- begin verbatim block   sys-->
<pre>
git clone git://github.com/username/My-Project.wiki.git
</pre>
</blockquote>   <! -- end verbatim block -->
This command makes a local copy of the pages in the directory
<tt>My-Project.wiki</tt>, which you may prefer to have at the same level
as the project directory itself in your directory tree.

<P>
Each wiki page has its own file, where the extension reflects
the markup language used, e.g., <tt>.md</tt> for Markdown and <tt>.rest</tt> for
reStructuredText. The wiki files are handled as other files in a
GitHub project, i.e., you need to pull before editing and then
perform commit and push. After the push you can reload the page
in the web browser to monitor the effect.

<P>
You may consider having the original text in <tt>doconce</tt> format and
generate the wiki in reStructuredText format.

<P>
Do changes, commit the usual way, and push by
<blockquote>    <!-- begin verbatim block   sys-->
<pre>
git push git@github.com:username/My-project.wiki.git
</pre>
</blockquote>   <! -- end verbatim block -->
The address can be stored as <tt>url</tt> in <tt>.git/config</tt> so that just a
<tt>git push</tt> works.

<P>

<P>
<h3>Project Web Pages</h3>
<P>
GitHub can also host a set of web pages for your project where you can
store various types of documentation. Here is a simple
recipe for creating a set of project web pages.

<P>

<ol>
<li> Go to to the  project page on <tt>github.com</tt> and click <em>Admin</em>.
<li> Check the <em>GitHub Pages</em> check box.
<li> Click on the <em>Automatic GitHub Page Generator</em> button in the pop up window.
<li> Go to the root directory of the project, <tt>My-Project</tt>,
   and run <tt>git fetch origin</tt>.
<li> Run <tt>git checkout -b gh-pages origin/gh-pages</tt>
</ol>

You have now a <em>new branch</em> called <tt>gh-pages</tt> of your project containing an
<tt>index.html</tt> file in the root directory (and in fact all files <em>not</em>
contained in the <em>master branch</em>, typically redundant files not to be
stored in the version control system).
You can populate this directory and subdirectories you create with
HTML and other files as you like.

<P>
The <tt>index.html</tt> page is invoked by the web address
<tt>http://username.github.com/My-Project/</tt>, where <tt>username</tt> is the GitHub
user name and <tt>My-Project</tt> is the project name.

<P>
<!-- Update this info when I have maintained gh-pages for a while! -->
<!-- Could also have a special section on branching in git (above, -->
<!-- then the info here is simple... YES!). -->

<P>
The web pages and project files are now in two different branches.
To see the branches, type <tt>git branch</tt> and the one you are in will
be marked with a star in the output. Swithing to the master branch
is done by <tt>git checkout master</tt>. Similarly, <tt>git checkout gh-pages</tt>
swithces to the gh-pages branch.

<P>
If branches diverge you can merge them by
<blockquote>    <!-- begin verbatim block   sys-->
<pre>
git merge otherbranch
</pre>
</blockquote>   <! -- end verbatim block -->
where <tt>otherbranch</tt> is the name of another branch. If there is a conflict
in the merge, there will be markers in problematic files. Run
<tt>git diff</tt> to show the problems. After a manual edit, do
<tt>git commit -a</tt>. Then you may run <tt>gitk</tt> to see a graphical illustration
of what has happened.

<P>
I recommend to have the master and gh-pages synchronized, at least
in projects where you need the source code files for generating
API documentation in the gh-pages branch. Then you will start
with pulling
everything from the master branch to the gh-pages branch.
Make sure the master branch is updated with anything that was
generated for the gh-pages branch. Finally you switch to the
master branch and merge with gh-pages so you get the autogenerated
<tt>index.html</tt>
file in the root directory:
<blockquote>    <!-- begin verbatim block   sys-->
<pre>
git merge master
git push origin gh-pages
git checkout master
git merge gh-pages
</pre>
</blockquote>   <! -- end verbatim block -->
You can now add the documentation to the project files and
keep them in the master branch.
Before publishing documents online,
make sure to update the gh-pages branch by
<blockquote>    <!-- begin verbatim block   sys-->
<pre>
git commit -am 'Ensure commit of everything in master branch'
git push origin master
git checkout gh-pages
git merge master
git push origin gh-pages
git checkout master
</pre>
</blockquote>   <! -- end verbatim block -->

<P>
Here is a very important point if you want to use Sphinx-generated
HTML pages: you <em>must</em> add an empty file <tt>.nojekyll</tt> in the top
directory of the project pages. Without it, the contents in <tt>_static</tt>
and <tt>_images</tt> directories (or any other directory starting with an
underscore) are not visible, i.e., the layout of the pages cannot make
use of Sphinx styles.  The problem can also be circumvented by
installing special Sphinx extensions (<a href="https://github.com/michaeljones/sphinx-to-github">sphinx-to-github</a> or <a href="http://pydoc.net/github-tools/0.1.3/">github-tools</a>).

<P>
<!-- See https://github.com/daler/sphinxdoc-test -->
<!-- for ideas on how to do sphinx documentation without full -->
<!-- mirroring as I do. -->
<!-- See also http://lucasbardella.com/report/hosting-your-sphinx-docs-in-github/ -->
<!-- Sphinx extension for github: https://github.com/michaeljones/sphinx-to-github -->

<P>

<P>
<h3>User Web Pages</h3>
<P>

<P>
GitHub also allows you to create user pages and organization pages not
tied to any specific project.
Your personal cite has address
<tt>http://username.github.com</tt>.
Go to your home page on <tt>github.com</tt> and click <em>New repository</em>,
and give it the project name <tt>username.github.com</tt>.
Then following the instructions that come up:
<blockquote>    <!-- begin verbatim block   sys-->
<pre>
mkdir username.github.com
cd username.github.com
git init
# make an index.html file with some test text
git add index.html
git commit -m 'First commit'
git remote add origin git@github.com:username/username.githun.com.git
git push -u origin master
</pre>
</blockquote>   <! -- end verbatim block -->
Go to <tt>http://username.github.com</tt> and see how the <tt>index.html</tt> is
rendered. You can now add various contents as in any ordinary
Git repository.
If you want to use Sphinx generated HTML pages, recall to add an empty file
<tt>.nojekyll</tt>.

<P>
<!-- Use gh-pages in a subfolder of the master branch: https://gist.github.com/825950 -->

<P>

<P>
<h2>Using Mercurial <a name="bitgit:hg"></A></h2>
<P>

<P>

<P>
<h3>The Basic Commands of Mercurial</h3>
<P>
You get started with your project on a new machine or another user
can get started with the project by the command
<blockquote>    <!-- begin verbatim block   sys-->
<pre>
hg clone ssh://hg@bitbucket.org/username/my-project
</pre>
</blockquote>   <! -- end verbatim block -->

<P>
Your typical working style with the <tt>my-project</tt> project goes as follows.
First you go to the desired directory where this project is stored on
your local computer and make sure
you have the latest versions of the files:
<blockquote>    <!-- begin verbatim block   sys-->
<pre>
hg pull
hg update
</pre>
</blockquote>   <! -- end verbatim block -->
These commands download the latest versions of the files from
your <tt>bitbucket.org</tt> repository and make them ready for changes on
your computer. The <tt>pull</tt> command requires a functioning Internet
connection.

<P>
You can now edit some files. Maybe you also add, remove, and move some files:
<blockquote>    <!-- begin verbatim block   sys-->
<pre>
hg add filename
hg remove filename
hg rename oldfilename ../somedir/newfilename
</pre>
</blockquote>   <! -- end verbatim block -->
The removal of a file is physically performed when you to a
<tt>hg commit</tt>. The file is never removed from the repository, only
hidden, so it is easy to get the file and its entire history
back at a later stage.

<P>
After some changes, you have to commit and push the files to the
repository at <tt>bitbucket.org</tt>:
<blockquote>    <!-- begin verbatim block   sys-->
<pre>
hg commit -m 'Description of changes.'
hg push
</pre>
</blockquote>   <! -- end verbatim block -->

<P>
The command
<blockquote>    <!-- begin verbatim block   sys-->
<pre>
hg stat
</pre>
</blockquote>   <! -- end verbatim block -->
shows the status of the individual files (<tt>M</tt> for modified, <tt>A</tt> for
added, <tt>R</tt> for removed), and you should pay attention to files with a
question mark because these are not tracked in the repository. It is
very easy to forget adding new files so <tt>hg stat</tt> is a useful command
to ensure that all files you want to track have been added to the
repository.

<P>
The power of <tt>hg</tt> and your file repository <tt>bitbucket.org</tt> is that
you can work with the project files on several computers and others can
also contribute to this project. The history of each file is recorded
and anyone can roll back to previous versions, if needed. You can easily see
who did what with the various files. For example,
<blockquote>    <!-- begin verbatim block   sys-->
<pre>
hg annotate -aun myfile
</pre>
</blockquote>   <! -- end verbatim block -->
lists the various lines in the file <tt>myfile</tt> annotated with the revision
number of the latest change of the line and the name of the user who
performed the change. Another command,
<blockquote>    <!-- begin verbatim block   sys-->
<pre>
hg log -p myfile
</pre>
</blockquote>   <! -- end verbatim block -->
lists the history of the file <tt>myfile</tt> in more detail so that you
can track the evolution of this file.

<P>
Mercurial has a two-level type of repository: there is global
repository for all users of the <tt>my-project</tt> tree at <tt>bitbucket.org</tt>,
but each user also has a local repository (automatically made). To
update files, one must first pull new files from the global repository
(<tt>pull</tt>) and then update the local repository (<tt>update</tt>), before any
file can be edited. The <tt>hg commit</tt> command saves files in the local
repository. One may run many <tt>hg commit</tt> commands to make a sequence
of corresponding versions of files in the local repository. Finally,
when the local versions are ready to be pushed to the global
repository, one runs the <tt>hg push</tt> command.

<P>
Older version control systems, including Subversion and CVS, have only
a global repository and no local ones.  The advantage of the two-level
repository is that you can change your files locally and keep track of
the changes (by doing <tt>hg commit</tt>) without affecting other users of
the files.  This feature allows you to commit changes to the global
repository only when you feel comfortable with the state of the files.
Nevertheless, if others work actively on the same files as you, it is
generally recommended to push often in order to exchange the latest
version of the files. This strategy may avoid problems with future
merging of files.

<P>
<h3>Merging Files with Mercurial <a name="bitgit:hgmerge"></A></h3>
<P>

<P>

<P>
It might have happened that others and you have edited the same files
at the same time. How should the edits then be combined?  Often the
<tt>hg update</tt> command is clever enough to merge the changes made by
different users automatically. If not, you have to run an explicit <tt>hg
merge</tt> command.  The <tt>hg merge</tt> program tries to use some merge
program on your computer system to automatically merge files. If this
failes, <tt>hg merge</tt> invokes some graphical tool to help you resolve the
conflict between files.  Example on popular merge programs for this
purpose are <tt>meld</tt>, <tt>xxdiff</tt>, <tt>kdiff3</tt>, and <tt>diffuse</tt>.  You can
specify the merge program, say <tt>xxdiff</tt>, by <tt>hg merge --tool xxdiff</tt>.
How you now proceed is dependent on the particular program. Usually,
for each change you must choose either your new local version of the
text, or your old local version of the text, or the version of the
text pulled from the global repository.  After using the merge program
successfully you must save the merged file and perform an <tt>hg commit</tt>
command on it, and perhaps do an <tt>hg push</tt> to also update the global
repository with the merged file(s).

<P>
Suppose you do not manage to merge using the merge tool. Then you have
to invoke the file, say <tt>myfile</tt> in an editor and do the merge
manually. There will often be lines starting with '<<<<', '=====',
and '>>>>` to mark conflicting texts (<em>merge markers</em>). After removing
these lines and editing the text manually, you must register the conflict
as resolved:
<blockquote>    <!-- begin verbatim block   sys-->
<pre>
hg resolve -m merge myfile
hg commit -m merge myfile
</pre>
</blockquote>   <! -- end verbatim block -->

<P>
You can read more about merging files in the <a href="http://hgbook.red-bean.com/read/a-tour-of-mercurial-merging-work.html">hgbook</a>.
We shall now illustrate the merge problems through an example.
Suppose we have a global repository <tt>tmp_repo</tt>, and two (cloned)
directories <tt>tmp1</tt> and <tt>tmp2</tt>, corresponding to two users, each with
their copy of the global repository.  There is only one file <tt>myfile</tt>
in the repository. We then simulate the two users and perform edits in
parallel. The shell script below simulates the two users and
illustrates the importance of pulling before editing and the need of
merge.

<P>
<blockquote>    <!-- begin verbatim block  -->
<pre>
#!/bin/sh
# Demo script for exemplifying hg merge

rm -rf tmp1 tmp2 tmp_repo   # Clean up previous runs

mkdir tmp_repo   # Global repository for testing
cd tmp_repo
cat &gt; myfile &lt;&lt;EOF
This is a little
test file for
exemplifying merge
of files in different
hg directories.
EOF
hg init   # Make hg global repository out of this directory
hg add    # Add all files not mentioned in ~/.hgignore
hg commit -m 'first commit'
cd ..

# Make a new hg repositories tmp1 and tmp2 (two users)
hg clone tmp_repo tmp1
hg clone tmp_repo tmp2

# Change myfile in the directory tmp1
cd tmp1
# Edit myfile: insert a new second line
perl -pi -e 's/a little\n/a little\ntmp1-add1\n/g' myfile
# Register change in local repository
hg commit -m 'Inserted a new second line in myfile.'
# Look at changes in this clone
hg log -p
# Register change in global repository tmp_repo
hg push
cd ..

# Change myfile in the directory tmp2 "in parallel"
cd tmp2
# Edit myfile: add a line at the end
cat &gt;&gt; myfile &lt;&lt;EOF
tmp2-add1
EOF
# Register change locally
hg commit -m 'Added a new line at the end'
# Register change globally
hg push
# Error message: global repository has changed,
# we need to pull those changes to local repository first
# and see if all files are compatible before we can update
# our own changes to the global repository.
# hg writes
# abort: push creates new remote head d0a2f8e6b9d9!
# (you should pull and merge or use push -f to force)

hg pull
# hg writes:
# added 1 changesets with 1 changes to 1 files (+1 heads)
# (run 'hg heads' to see heads, 'hg merge' to merge)
hg merge
# Successful merge!
cat myfile
hg commit -m merge
hg push
cd ..

# Perform new changes in parallel in tmp1 and tmp2,
# this time causing hg merge to fail

# Change myfile in the directory tmp1
cd tmp1
# Do it all right by pulling and updating first
hg pull
hg update
# Edit myfile: insert "just" in first line.
perl -pi -e 's/a little/tmp1-add2 a little/g' myfile
# Register change in local repository
hg commit -m 'Inserted "just" in first line.'
# Register change in global repository tmp_repo
hg push
cd ..

# Change myfile in the directory tmp2 "in parallel"
cd tmp2
# Edit myfile: replace little by modest
perl -pi -e 's/a little/a tmp2-replace1\ntmp2-add2\n/g' myfile
# Register change locally
hg commit -m 'Replaced "little" by "modest"'
# Register change globally
hg push
# Not possible: need to pull changes in the global repository
hg pull
hg update
# hg update aborts: we have to run hg merge
diff myfile ../tmp_repo/myfile
echo 'Now you must do hg merge manually'
</pre>
</blockquote>   <! -- end verbatim block -->

<P>
Try to run this <a href="html/_static-bitgithg_merge.sh">file</a> named
<tt>hg_merge.sh</tt> by <tt>sh -x hg_merge.sh</tt>.
To resolve the resulting merge conflict you need to go to the <tt>tmp2</tt>
directory, run <tt>hg merge --tool meld</tt> and use the <tt>meld</tt> tool to
select which text snippets that should make up the final, merged
version. Save and quit <tt>meld</tt> and peform <tt>hg commit -m merge</tt>.  You
can now do <tt>hg push</tt> successfully to update the global repository.

<P>
<h3>More Documentation on Mercurial</h3>
<P>

<ul>
 <li> <a href="http://mercurial.selenic.com/wiki/QuickStart">Mercurial Quick Start</a> (for the impatient)
 <li> <a href="http://mercurial.selenic.com/wiki/FAQ">Mercurial FAQ</a>
 <li> <a href="http://mercurial.selenic.com/wiki/Tutorial">Mercurial Tutorial</a>
 <li> <a href="http://hgbook.red-bean.com/">Mercurial: The Definitive Guide</a> (online or printed book)
</ul>
<h2>Using Git <a name="bitgit:git"></A></h2>
<P>

<P>

<P>
<h3>The Basic Commands of Git</h3>
<P>
You get started with your project on a new machine, or another user
can get started with the project,
by running
<blockquote>    <!-- begin verbatim block   sys-->
<pre>
git clone git@github.com:username/My-Project.git
cd My-Project
ls
</pre>
</blockquote>   <! -- end verbatim block -->
Recall to replace <tt>username</tt> by your real user name and <tt>My-Project</tt> by the
actual project name.

<P>
The typical work flow with the "My Project" project starts with
updating the local repository by going to the <tt>My-Project</tt> directory
and writing
<blockquote>    <!-- begin verbatim block   sys-->
<pre>
git pull origin master
</pre>
</blockquote>   <! -- end verbatim block -->

<P>
After editing files, adding new files, deleting files, or renaming files,
<blockquote>    <!-- begin verbatim block   sys-->
<pre>
git add myfile1 myfile2.* yourdir
git rm yourfile
git rm -r yourdir
git mv thisfile thatname
git mv thisfile ../thatdir
</pre>
</blockquote>   <! -- end verbatim block -->
it is time to commit your changes (note the <tt>-am</tt> option):
<blockquote>    <!-- begin verbatim block   sys-->
<pre>
git commit -am 'Description of changes.'
</pre>
</blockquote>   <! -- end verbatim block -->
You may perform many commits, to keep track of small changes, before
you push your changes to the global repository:
<blockquote>    <!-- begin verbatim block   sys-->
<pre>
git push origin master
</pre>
</blockquote>   <! -- end verbatim block -->

<P>
To see the status of files, run
<blockquote>    <!-- begin verbatim block   sys-->
<pre>
git status -s
</pre>
</blockquote>   <! -- end verbatim block -->
Files are marked with <tt>A</tt> for added, <tt>M</tt> for modified, and so on.

<P>
A nice graphical tool allows you to view all changes, or just
the latest ones:
<blockquote>    <!-- begin verbatim block   sys-->
<pre>
gitk --all
gitk --since="2 weeks ago"
</pre>
</blockquote>   <! -- end verbatim block -->
You can also view changes to all files or some selected ones
in the terminal window:
<blockquote>    <!-- begin verbatim block   sys-->
<pre>
git log -p                        # all changes to all files
git log --stat --summary          # more compact summary
git log --stat --summary  subdir  # only files in subdir folder
</pre>
</blockquote>   <! -- end verbatim block -->
To see who did what when, use <tt>git blame</tt>:
<blockquote>    <!-- begin verbatim block   sys-->
<pre>
git blame subdir/myfile.txt
git blame --since="1 week" subdir/myfile.txt
</pre>
</blockquote>   <! -- end verbatim block -->

<P>
<h3>Merging Files with Git <a name="bitgit:gitmerge"></A></h3>
<P>

<P>

<P>
The <tt>git pull</tt> command fetches new files from the repository and
tries to perform an automatic merge if there are conflicts between
the local files and the files in the repository.
Git will write a message if the merge is unsuccessful for one or
more files. These files will have to be edited manually.
Merge markers of the type '>>>>>', '======', and '<<<<<' have been
inserted by Git to mark sections of a file where the version in the
repository differ from the local version. You must decide which
lines that are to appear in the final, merged version. When done,
perform <tt>git commit</tt> and the conflicts are resolved.

<P>
Below is a Unix shell script illustrating how to make a global
repository in Git, and how two users clone this repository and
perform edits in parallel. There is one file <tt>myfile</tt> in the
repository.

<P>
<blockquote>    <!-- begin verbatim block  -->
<pre>
#!/bin/sh
# Demo script for exemplifying git and merge

rm -rf tmp1 tmp2 tmp_repo   # Clean up previous runs

mkdir tmp_repo   # Global repository for testing
cd tmp_repo
git --bare init --shared
cd ..

# Make a repo that can be pushed to tmp_repo
mkdir _tmp
cd _tmp
cat &gt; myfile &lt;&lt;EOF
This is a little
test file for
exemplifying merge
of files in different
git directories.
EOF
git init
git add .   # Add all files not mentioned in ~/.gitignore
git commit -am 'first commit'
git push ../tmp_repo master
cd ..
rm -rf _tmp

# Make a new hg repositories tmp1 and tmp2 (two users)
git clone tmp_repo tmp1
git clone tmp_repo tmp2
# Change myfile in the directory tmp1
cd tmp1
# Edit myfile: insert a new second line
perl -pi -e 's/a little\n/a little\ntmp1-add1\n/g' myfile
# Register change in local repository
git commit -am 'Inserted a new second line in myfile.'
# Look at changes in this clone
git log -p
# or a more compact summary
git log --stat --summary
# or graphically
#gitk
# Register change in global repository tmp_repo
git push origin master
cd ..

# Change myfile in the directory tmp2 "in parallel"
cd tmp2
# Edit myfile: add a line at the end
cat &gt;&gt; myfile &lt;&lt;EOF
tmp2-add1
EOF
# Register change locally
git commit -am 'Added a new line at the end'
# Register change globally
git push origin master
# Error message: global repository has changed,
# we need to pull those changes to local repository first
# and see if all files are compatible before we can update
# our own changes to the global repository.
# git writes
#To /home/hpl/vc/scripting/manu/py/bitgit/src-bitgit/tmp_repo
# ! [rejected]        master -&gt; master (non-fast-forward)
#error: failed to push some refs to ...

git pull origin master
# git writes:
#Auto-merging myfile
#Merge made by recursive.
# myfile |    1 +
# 1 files changed, 1 insertions(+), 0 deletions(-)
cat myfile  # successful merge!
git commit -am merge
git push origin master
cd ..

# Perform new changes in parallel in tmp1 and tmp2,
# this time causing hg merge to fail

# Change myfile in the directory tmp1
cd tmp1
# Do it all right by pulling and updating first
git pull origin master
# Edit myfile: insert "just" in first line.
perl -pi -e 's/a little/tmp1-add2 a little/g' myfile
# Register change in local repository
git commit -am 'Inserted "just" in first line.'
# Register change in global repository tmp_repo
git push origin master
cd ..

# Change myfile in the directory tmp2 "in parallel"
cd tmp2
# Edit myfile: replace little by modest
perl -pi -e 's/a little/a tmp2-replace1\ntmp2-add2\n/g' myfile
# Register change locally
git commit -am 'Replaced "little" by "modest"'
# Register change globally
git push origin master
# Not possible: need to pull changes in the global repository
git pull origin master
# git writes
#CONFLICT (content): Merge conflict in myfile
#Automatic merge failed; fix conflicts and then commit the result.
# we have to do a manual merge
cat myfile
echo 'Now you must edit myfile manually'
</pre>
</blockquote>   <! -- end verbatim block -->

<P>
You may run this <a href="html/_static-bitgitgit_merge.sh">file</a> named
<tt>git_merge.sh</tt> by <tt>sh -x git_merge.sh</tt>.
At the end, the versions of <tt>myfile</tt> in the
repository and the <tt>tmp2</tt> directory are in conflict. Git tried
to merge the two versions, but failed. Merge markers are left in
<tt>tmp2/myfile</tt>:
<blockquote>    <!-- begin verbatim block   dat-->
<pre>
&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD
This is a tmp2-replace1
tmp2-add2

=======
This is tmp1-add2 a little
&gt;&gt;&gt;&gt;&gt;&gt;&gt; ad9b9f631c4cc586ea951390d9415ac83bcc9c01
tmp1-add1
test file for
exemplifying merge
of files in different
git directories.
tmp2-add1
</pre>
</blockquote>   <! -- end verbatim block -->
Launch a text editor and edit the file so that it becomes correct.
Then run <tt>git commit -am merge</tt> to finalize the merge.

<P>

<P>

<P>
<h3>More Documentation on Git</h3>
<P>

<ul>
 <li> <a href="http://schacon.github.com/git/everyday.html">Everyday GIT With 20 Commands Or So</a>
 <li> <a href="http://book.git-scm.com/">Git Community Book</a>
 <li> <a href="http://hoth.entp.com/output/git_for_designers.html">Git for Designers</a> (aimed a people with no previous knowledge of version control systems)
 <li> <a href="http://www-cs-students.stanford.edu/~blynn/gitmagic/ch02.html">Git Magic: Basic Tricks</a>
 <li> The official <a href="http://schacon.github.com/git/gittutorial.html">Git Tutorial</a>
 <li> <a href="http://www.youtube.com/watch?v=TPY8UwlTIc0&feature=related">Git Tutorial Video</a> on YouTube
 <li> <a href="http://wiki.sourcemage.org/Git_Guide">Git Questions</a>
 <li> <a href="http://gitref.org">Git Reference</a> (can also be used as a tutorial on Git)
 <li> <a href="http://schacon.github.com/git/user-manual.html">Git User Manual</a>
 <li> <a href="http://git-scm.com/">Git home page</a>
 <li> <a href="http://mercurial.selenic.com/wiki/GitConcepts#Command_equivalence_table">Git and Mercurial command equivalence table</a>
</ul>

</body>
</html>
    