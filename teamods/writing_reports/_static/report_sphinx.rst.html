<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN"
   "http://www.w3.org/TR/html4/strict.dtd">

<html>
<head>
  <title></title>
  <meta http-equiv="content-type" content="text/html; charset=latin1">
  <style type="text/css">
td.linenos { background-color: #f0f0f0; padding-right: 10px; }
span.lineno { background-color: #f0f0f0; padding: 0 5px 0 5px; }
pre { line-height: 125%; }
body .hll { background-color: #ffffcc }
body  { background: #f8f8f8; }
body .c { color: #008800; font-style: italic } /* Comment */
body .err { border: 1px solid #FF0000 } /* Error */
body .k { color: #AA22FF; font-weight: bold } /* Keyword */
body .o { color: #666666 } /* Operator */
body .cm { color: #008800; font-style: italic } /* Comment.Multiline */
body .cp { color: #008800 } /* Comment.Preproc */
body .c1 { color: #008800; font-style: italic } /* Comment.Single */
body .cs { color: #008800; font-weight: bold } /* Comment.Special */
body .gd { color: #A00000 } /* Generic.Deleted */
body .ge { font-style: italic } /* Generic.Emph */
body .gr { color: #FF0000 } /* Generic.Error */
body .gh { color: #000080; font-weight: bold } /* Generic.Heading */
body .gi { color: #00A000 } /* Generic.Inserted */
body .go { color: #888888 } /* Generic.Output */
body .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
body .gs { font-weight: bold } /* Generic.Strong */
body .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
body .gt { color: #0044DD } /* Generic.Traceback */
body .kc { color: #AA22FF; font-weight: bold } /* Keyword.Constant */
body .kd { color: #AA22FF; font-weight: bold } /* Keyword.Declaration */
body .kn { color: #AA22FF; font-weight: bold } /* Keyword.Namespace */
body .kp { color: #AA22FF } /* Keyword.Pseudo */
body .kr { color: #AA22FF; font-weight: bold } /* Keyword.Reserved */
body .kt { color: #00BB00; font-weight: bold } /* Keyword.Type */
body .m { color: #666666 } /* Literal.Number */
body .s { color: #BB4444 } /* Literal.String */
body .na { color: #BB4444 } /* Name.Attribute */
body .nb { color: #AA22FF } /* Name.Builtin */
body .nc { color: #0000FF } /* Name.Class */
body .no { color: #880000 } /* Name.Constant */
body .nd { color: #AA22FF } /* Name.Decorator */
body .ni { color: #999999; font-weight: bold } /* Name.Entity */
body .ne { color: #D2413A; font-weight: bold } /* Name.Exception */
body .nf { color: #00A000 } /* Name.Function */
body .nl { color: #A0A000 } /* Name.Label */
body .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
body .nt { color: #008000; font-weight: bold } /* Name.Tag */
body .nv { color: #B8860B } /* Name.Variable */
body .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
body .w { color: #bbbbbb } /* Text.Whitespace */
body .mf { color: #666666 } /* Literal.Number.Float */
body .mh { color: #666666 } /* Literal.Number.Hex */
body .mi { color: #666666 } /* Literal.Number.Integer */
body .mo { color: #666666 } /* Literal.Number.Oct */
body .sb { color: #BB4444 } /* Literal.String.Backtick */
body .sc { color: #BB4444 } /* Literal.String.Char */
body .sd { color: #BB4444; font-style: italic } /* Literal.String.Doc */
body .s2 { color: #BB4444 } /* Literal.String.Double */
body .se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
body .sh { color: #BB4444 } /* Literal.String.Heredoc */
body .si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
body .sx { color: #008000 } /* Literal.String.Other */
body .sr { color: #BB6688 } /* Literal.String.Regex */
body .s1 { color: #BB4444 } /* Literal.String.Single */
body .ss { color: #B8860B } /* Literal.String.Symbol */
body .bp { color: #AA22FF } /* Name.Builtin.Pseudo */
body .vc { color: #B8860B } /* Name.Variable.Class */
body .vg { color: #B8860B } /* Name.Variable.Global */
body .vi { color: #B8860B } /* Name.Variable.Instance */
body .il { color: #666666 } /* Literal.Number.Integer.Long */

  </style>
</head>
<body>
<h2></h2>

<div class="highlight"><pre><span class="cp">.. Automatically generated reST file from Doconce source</span>
<span class="cp">   (http://code.google.com/p/doconce/)</span>


<span class="gh">Experiments with Schemes for Exponential Decay</span>
<span class="gh">==============================================</span>

<span class="nc">:Author:</span> <span class="nf">Hans Petter Langtangen (hpl at simula.no)</span>
<span class="nc">:Date:</span> <span class="nf">Jun 18, 2013</span>

<span class="ge">*Summary.*</span> This report investigates the accuracy of three finite difference
schemes for the ordinary differential equation <span class="na">:math:</span><span class="nv">`u&#39;=-au`</span> with the
aid of numerical experiments. Numerical artifacts are in particular
demonstrated.








<span class="p">..</span> <span class="nt">_math:</span>problem:


<span class="gh">Mathematical problem</span>
<span class="gh">====================</span>



<span class="p">..</span> <span class="ow">index</span><span class="p">::</span> model problem

<span class="p">..</span> <span class="ow">index</span><span class="p">::</span> exponential decay


We address the initial-value problem


<span class="p">..</span> <span class="ow">math</span><span class="p">::</span>
   <span class="nc">:label:</span> <span class="nf">ode</span>
        
        u&#39;(t) = -au(t), \quad t \in (0,T], 
        



<span class="p">..</span> <span class="ow">math</span><span class="p">::</span>
   <span class="nc">:label:</span> <span class="nf">initial:value</span>
         
        u(0)  = I,                         
        

where <span class="na">:math:</span><span class="nv">`a`</span>, <span class="na">:math:</span><span class="nv">`I`</span>, and <span class="na">:math:</span><span class="nv">`T`</span> are prescribed parameters, and <span class="na">:math:</span><span class="nv">`u(t)`</span> is
the unknown function to be estimated. This mathematical model
is relevant for physical phenomena featuring exponential decay
in time, e.g., vertical pressure variation in the atmosphere,
cooling of an object, and radioactive decay.

<span class="p">..</span> <span class="nt">_numerical:</span>problem:

<span class="gh">Numerical solution method</span>
<span class="gh">=========================</span>



<span class="p">..</span> <span class="ow">index</span><span class="p">::</span> mesh in time

<span class="p">..</span> <span class="ow">index</span><span class="p">::</span> theta-rule

<span class="p">..</span> <span class="ow">index</span><span class="p">::</span> numerical scheme


<span class="p">..</span> <span class="ow">index</span><span class="p">::</span> finite difference scheme


We introduce a mesh in time with points <span class="na">:math:</span><span class="nv">`0= t_0&lt; t_1 \cdots &lt; t_{N_t}=T`</span>.
For simplicity, we assume constant spacing <span class="na">:math:</span><span class="nv">`\Delta t`</span> between the
mesh points: <span class="na">:math:</span><span class="nv">`\Delta t = t_{n}-t_{n-1}`</span>, <span class="na">:math:</span><span class="nv">`n=1,\ldots,N_t`</span>. Let
<span class="na">:math:</span><span class="nv">`u^n`</span> be the numerical approximation to the exact solution at <span class="na">:math:</span><span class="nv">`t_n`</span>.

The <span class="na">:math:</span><span class="nv">`\theta`</span>-rule <span class="s">[Ref1]_</span>
is used to solve <span class="na">:eq:</span><span class="nv">`ode`</span> numerically:


<span class="p">..</span> <span class="ow">math</span><span class="p">::</span>
        
        u^{n+1} = \frac{1 - (1-\theta) a\Delta t}{1 + \theta a\Delta t}u^n,
        

for <span class="na">:math:</span><span class="nv">`n=0,1,\ldots,N_t-1`</span>. This scheme corresponds to

  <span class="m">*</span> The <span class="s">`Forward Euler </span><span class="si">&lt;http://en.wikipedia.org/wiki/Forward_Euler_method&gt;</span><span class="s">`_</span>
    scheme when <span class="na">:math:</span><span class="nv">`\theta=0`</span>

  <span class="m">*</span> The <span class="s">`Backward Euler </span><span class="si">&lt;http://en.wikipedia.org/wiki/Backward_Euler_method&gt;</span><span class="s">`_</span>
    scheme when <span class="na">:math:</span><span class="nv">`\theta=1`</span>

  <span class="m">*</span> The <span class="s">`Crank-Nicolson </span><span class="si">&lt;http://en.wikipedia.org/wiki/Crank-Nicolson&gt;</span><span class="s">`_</span>
    scheme when <span class="na">:math:</span><span class="nv">`\theta=1/2`</span>

<span class="gh">Implementation</span>
<span class="gh">==============</span>


The numerical method is implemented in a Python function
<span class="s">[Ref2]_</span> <span class="s">``solver``</span> (found in the <span class="s">`decay_mod </span><span class="si">&lt;https://github.com/hplgit/INF5620/blob/gh-pages/src/decay/experiments/dc_mod.py&gt;</span><span class="s">`_</span> module):


<span class="p">..</span> <span class="ow">code-block</span><span class="p">::</span> python

        def solver(I, a, T, dt, theta):
            &quot;&quot;&quot;Solve u&#39;=-a*u, u(0)=I, for t in (0,T] with steps of dt.&quot;&quot;&quot;
            dt = float(dt)            # avoid integer division
            Nt = int(round(T/dt))     # no of time intervals
            T = Nt*dt                 # adjust T to fit time step dt
            u = zeros(Nt+1)           # array of u[n] values
            t = linspace(0, T, Nt+1)  # time mesh
        
            u[0] = I                  # assign initial condition
            for n in range(0, Nt):    # n=0,1,...,Nt-1
                u[n+1] = (1 - (1-theta)<span class="ge">*a*</span>dt)/(1 + theta<span class="ge">*dt*</span>a)*u[n]
            return u, t



<span class="gh">Numerical experiments</span>
<span class="gh">=====================</span>



<span class="p">..</span> <span class="ow">index</span><span class="p">::</span> numerical experiments


We define a set of numerical experiments where <span class="na">:math:</span><span class="nv">`I`</span>, <span class="na">:math:</span><span class="nv">`a`</span>, and <span class="na">:math:</span><span class="nv">`T`</span> are
fixed, while <span class="na">:math:</span><span class="nv">`\Delta t`</span> and <span class="na">:math:</span><span class="nv">`\theta`</span> are varied.
In particular, <span class="na">:math:</span><span class="nv">`I=1`</span>, <span class="na">:math:</span><span class="nv">`a=2`</span>, <span class="na">:math:</span><span class="nv">`\Delta t = 1.25, 0.75, 0.5, 0.1`</span>.



<span class="gh">The Backward Euler method</span>
<span class="gh">-------------------------</span>




<span class="p">..</span> <span class="ow">index</span><span class="p">::</span> BE



<span class="p">..</span> <span class="ow">figure</span><span class="p">::</span> BE.png
   :width: 800





<span class="gh">The Crank-Nicolson method</span>
<span class="gh">-------------------------</span>




<span class="p">..</span> <span class="ow">index</span><span class="p">::</span> CN



<span class="p">..</span> <span class="ow">figure</span><span class="p">::</span> CN.png
   :width: 800





<span class="gh">The Forward Euler method</span>
<span class="gh">------------------------</span>




<span class="p">..</span> <span class="ow">index</span><span class="p">::</span> FE



<span class="p">..</span> <span class="ow">figure</span><span class="p">::</span> FE.png
   :width: 800





<span class="gh">Error vs :math:`\Delta t`</span>
<span class="gh">-------------------------</span>



<span class="p">..</span> <span class="ow">index</span><span class="p">::</span> error vs time step


How <span class="na">:math:</span><span class="nv">`E`</span> varies with <span class="na">:math:</span><span class="nv">`\Delta t`</span> for <span class="na">:math:</span><span class="nv">`\theta=0,0.5,1`</span>
is shown below.



<span class="p">..</span> <span class="ow">admonition</span><span class="p">::</span> Observe

   The data points for the three largest <span class="na">:math:</span><span class="nv">`\Delta t`</span> values in the
   Forward Euler method are not relevant as the solution behaves
   non-physically.


<span class="p">..</span> <span class="ow">figure</span><span class="p">::</span> error.png
   :width: 400





<span class="p">..</span> <span class="ow">admonition</span><span class="p">::</span> Summary

   <span class="m">1.</span> <span class="na">:math:</span><span class="nv">`\theta =1`</span>: <span class="na">:math:</span><span class="nv">`E\sim \Delta t`</span> (first-order convergence).
   
   <span class="m">2.</span> <span class="na">:math:</span><span class="nv">`\theta =0.5`</span>: <span class="na">:math:</span><span class="nv">`E\sim \Delta t^2`</span> (second-order convergence).
   
   <span class="m">3.</span> <span class="na">:math:</span><span class="nv">`\theta =1`</span> is always stable and gives qualitatively corrects results.
   
   <span class="m">4.</span> <span class="na">:math:</span><span class="nv">`\theta =0.5`</span> never blows up, but may give oscillating solutions
      if <span class="na">:math:</span><span class="nv">`\Delta t`</span> is not sufficiently small.
   
   <span class="m">5.</span> <span class="na">:math:</span><span class="nv">`\theta =0`</span> suffers from fast-growing solution if <span class="na">:math:</span><span class="nv">`\Delta t`</span> is
      not small enough, but even below this limit one can have oscillating
      solutions that disappear if <span class="na">:math:</span><span class="nv">`\Delta t`</span> is sufficiently small.


<span class="gh">Bibliography</span>
<span class="gh">============</span>

<span class="p">..</span> <span class="nt">[Ref1]</span>
   <span class="gs">**A. Iserles**</span>. <span class="ge">*A First Course in the Numerical Analysis of Differential Equations*</span>,
   Cambridge University Press,
   2009.

<span class="p">..</span> <span class="nt">[Ref2]</span>
   <span class="gs">**H. P. Langtangen**</span>. <span class="ge">*A Primer on Scientific Programming With Python*</span>,
   Springer,
   2012.
</pre></div>
</body>
</html>
