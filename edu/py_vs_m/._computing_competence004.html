<!--
Automatically generated HTML file from DocOnce source
(https://github.com/hplgit/doconce/)
-->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="DocOnce: https://github.com/hplgit/doconce/" />
<meta name="description" content="Learning Outcomes for Computing Competence">

<title>Learning Outcomes for Computing Competence</title>

<!-- Bootstrap style: bootstrap -->
<link href="http://netdna.bootstrapcdn.com/bootstrap/3.1.1/css/bootstrap.min.css" rel="stylesheet">
<!-- not necessary
<link href="http://netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css" rel="stylesheet">
-->

<style type="text/css">

/* Add scrollbar to dropdown menus in bootstrap navigation bar */
.dropdown-menu {
   height: auto;
   max-height: 400px;
   overflow-x: hidden;
}
</style>


</head>

<!-- tocinfo
{'highest level': 1,
 'sections': [(u'Why is computing competence important?', 1, None, '___sec0'),
              (u'General learning outcomes for computing competence',
               1,
               u'sec:learning_outcomes',
               u'sec:learning_outcomes'),
              (u'Case study', 1, None, '___sec2'),
              (u'Exercise for the case study', 2, None, '___sec3'),
              (u'Solution 1: Minimalistic Matlab', 2, None, '___sec4'),
              (u'Solution 2: Matlab with functions', 2, None, '___sec5'),
              (u'Solution 3: Standard Python', 2, None, '___sec6'),
              (u'Verification and testing frameworks',
               1,
               u'sec:verify',
               u'sec:verify'),
              (u'A simple test function', 2, None, '___sec8'),
              (u'A proper test function for the nose or pytest test framework',
               2,
               None,
               '___sec9'),
              (u'Use of symbolic computing for exact results',
               2,
               None,
               '___sec10'),
              (u'Use relative errors', 2, None, '___sec11'),
              (u'Test function for the convergence rate',
               2,
               None,
               '___sec12'),
              (u'Tests in Matlab', 2, None, '___sec13'),
              (u'Rounding errors', 2, None, '___sec14'),
              (u'Incorporation of other learning outcomes',
               1,
               None,
               '___sec15'),
              (u'High-performance computing: vectorization',
               2,
               u'sec:HPC:vec',
               u'sec:HPC:vec'),
              (u'High-performance computing: memory usage',
               2,
               None,
               '___sec17'),
              (u'High-performance computing: parallelization',
               2,
               None,
               '___sec18'),
              (u'Understanding of approximation errors', 2, None, '___sec19'),
              (u'Overview of advanced algorithms', 2, None, '___sec20'),
              (u'Uncertainty quantification', 2, None, '___sec21'),
              (u'Extended exercise', 1, None, '___sec22'),
              (u'A Python solution', 2, None, '___sec23'),
              (u'Solution 4: a Java OO program', 1, None, '___sec24'),
              (u'Conclusions', 1, None, '___sec25')]}
end of tocinfo -->

<body>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
     equationNumbers: {  autoNumber: "none"  },
     extensions: ["AMSmath.js", "AMSsymbols.js", "autobold.js", "color.js"]
  }
});
</script>
<script type="text/javascript"
 src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>



    
<!-- Bootstrap navigation bar -->
<div class="navbar navbar-default navbar-fixed-top">
  <div class="navbar-header">
    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-responsive-collapse">
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </button>
    <a class="navbar-brand" href="computing_competence.html">Learning Outcomes for Computing Competence</a>
  </div>

  <div class="navbar-collapse collapse navbar-responsive-collapse">
    <ul class="nav navbar-nav navbar-right">
      <li class="dropdown">
        <a href="#" class="dropdown-toggle" data-toggle="dropdown">Contents <b class="caret"></b></a>
        <ul class="dropdown-menu">
     <!-- navigation toc: --> <li><a href="._computing_competence002.html#___sec0" style="font-size: 80%;"><b>Why is computing competence important?</b></a></li>
     <!-- navigation toc: --> <li><a href="._computing_competence003.html#sec:learning_outcomes" style="font-size: 80%;"><b>General learning outcomes for computing competence</b></a></li>
     <!-- navigation toc: --> <li><a href="#___sec2" style="font-size: 80%;"><b>Case study</b></a></li>
     <!-- navigation toc: --> <li><a href="#___sec3" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Exercise for the case study</a></li>
     <!-- navigation toc: --> <li><a href="#___sec4" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Solution 1: Minimalistic Matlab</a></li>
     <!-- navigation toc: --> <li><a href="#___sec5" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Solution 2: Matlab with functions</a></li>
     <!-- navigation toc: --> <li><a href="#___sec6" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Solution 3: Standard Python</a></li>
     <!-- navigation toc: --> <li><a href="#sec:verify" style="font-size: 80%;"><b>Verification and testing frameworks</b></a></li>
     <!-- navigation toc: --> <li><a href="#___sec8" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;A simple test function</a></li>
     <!-- navigation toc: --> <li><a href="#___sec9" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;A proper test function for the nose or pytest test framework</a></li>
     <!-- navigation toc: --> <li><a href="#___sec10" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Use of symbolic computing for exact results</a></li>
     <!-- navigation toc: --> <li><a href="#___sec11" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Use relative errors</a></li>
     <!-- navigation toc: --> <li><a href="#___sec12" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Test function for the convergence rate</a></li>
     <!-- navigation toc: --> <li><a href="#___sec13" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Tests in Matlab</a></li>
     <!-- navigation toc: --> <li><a href="#___sec14" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Rounding errors</a></li>
     <!-- navigation toc: --> <li><a href="#___sec15" style="font-size: 80%;"><b>Incorporation of other learning outcomes</b></a></li>
     <!-- navigation toc: --> <li><a href="#sec:HPC:vec" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;High-performance computing: vectorization</a></li>
     <!-- navigation toc: --> <li><a href="#___sec17" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;High-performance computing: memory usage</a></li>
     <!-- navigation toc: --> <li><a href="#___sec18" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;High-performance computing: parallelization</a></li>
     <!-- navigation toc: --> <li><a href="#___sec19" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Understanding of approximation errors</a></li>
     <!-- navigation toc: --> <li><a href="#___sec20" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Overview of advanced algorithms</a></li>
     <!-- navigation toc: --> <li><a href="#___sec21" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Uncertainty quantification</a></li>
     <!-- navigation toc: --> <li><a href="._computing_competence005.html#___sec22" style="font-size: 80%;"><b>Extended exercise</b></a></li>
     <!-- navigation toc: --> <li><a href="._computing_competence005.html#___sec23" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;A Python solution</a></li>
     <!-- navigation toc: --> <li><a href="._computing_competence005.html#___sec24" style="font-size: 80%;"><b>Solution 4: a Java OO program</b></a></li>
     <!-- navigation toc: --> <li><a href="._computing_competence006.html#___sec25" style="font-size: 80%;"><b>Conclusions</b></a></li>

        </ul>
      </li>
    </ul>
  </div>
</div>
</div> <!-- end of navigation bar -->

<div class="container">

<p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p> <!-- add vertical space -->

<a name="part0004"></a>
<!-- !split -->

<h1 id="___sec2">Case study </h1>

<p>
The series of goals above are briefly stated, but illustrated here in
detail for a special, simple case study:
numerical integration by the Trapezoidal rule.

<p>
Many science courses now have examples and exercises involving
implementation and application of numerical methods. How to structure
and verify such numerical programs has, unfortunately, received little
attention in university education and the literature.
Students and teachers occasionally write programs that
are too tailored to the problem at hand instead of being a good
starting point for future extensions, and testing is often limited
to running a case where the answer seems reasonable. The standards
of computing need to be raised to the levels found in experimental
physics, chemistry, and biology.

<p>
<div class="alert alert-block alert-success alert-text-normal"><b>Observation: poor versus good design of programs depends on the programming language (!).</b>
A common conception is that simple scientific computing
scripts implemented in Matlab and Python are very similar - almost
identical.  However, practice observed by this author shows that
students and teachers tend to make software with bad design in
Matlab, while the design improves significantly when they use
Python. Bad design means specializing a generic algorithm to a specific
problem and making &quot;flat&quot; programs without functions. Good design means
reusable implementations of generic algorithms and proper use of functions
(or classes). The coming text demonstrates the assertions.
</div>


<h2 id="___sec3">Exercise for the case study </h2>

<p>
Integrate the function \( g(t)=\exp{(-t^4)} \) from
-2 to 2 using the Trapezoidal rule, defined by

$$
\begin{equation}
\int_a^b f(x)dx \approx h\left( {1\over2}(f(a) + f(b)) +
\sum_{i=1}^{n-1} f(a+ih)\right), \quad h = (b-a)/n
\tag{1}
\end{equation}
$$

<h2 id="___sec4">Solution 1: Minimalistic Matlab </h2>

<p>
Many will attempt to solve the problem by this simple program in Matlab:

<p>

<!-- code=matlab (!bc mpro) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">a = <span style="color: #666666">-2</span>; b = <span style="color: #666666">2</span>;
n = <span style="color: #666666">1000</span>;
h = (b<span style="color: #666666">-</span>a)<span style="color: #666666">/</span>n;
s = <span style="color: #666666">0.5*</span>(<span style="color: #008000">exp</span>(<span style="color: #666666">-</span>a^<span style="color: #666666">4</span>) <span style="color: #666666">+</span> <span style="color: #008000">exp</span>(<span style="color: #666666">-</span>b^<span style="color: #666666">4</span>));
<span style="color: #008000; font-weight: bold">for</span> <span style="color: #008000">i</span> = <span style="color: #666666">1</span>:n<span style="color: #666666">-1</span>
    s = s <span style="color: #666666">+</span> <span style="color: #008000">exp</span>(<span style="color: #666666">-</span>(a<span style="color: #666666">+</span><span style="color: #008000">i</span><span style="color: #666666">*</span>h)^<span style="color: #666666">4</span>);
<span style="color: #008000; font-weight: bold">end</span>
r = h<span style="color: #666666">*</span>s;
r
</pre></div>
<p>
The solution is minimalistic and correct. Nevertheless, this solution
has a common pedagogical and software engineering flaw: a special function
\( \exp(-t^4) \) is merged into a general algorithm
<a href="#mjx-eqn-1">(1)</a> for integrating an arbitrary function \( f(x) \).

<p>
The writer of the program runs it and reports the result:
1.81280494737.  How can one assess that this result is correct? There
is no exactly known result to compare with.  Also, the program above
is not well suited for switching to an integrand where we can compare
with an exact answer, because several lines need modification.

<h2 id="___sec5">Solution 2: Matlab with functions </h2>

<p>
A fundamental software engineering practice is to use <em>functions</em> for
splitting a program into natural pieces, and if possible, make these
functions sufficiently general to be reused in other problems.  In the
present problem we should strive for the following principles:

<ol>
 <li> Since the formula for the Trapezoidal rule works for &quot;any&quot;
    function, the implementation of the formula should be in
    terms of a <em>function</em> taking \( f(x) \), \( a \), \( b \), and
    \( n \) as arguments.</li>
 <li> The special \( g(t) \) formula
    is implemented as a separate function.</li>
 <li> A main program solves the <em>specific problem in question</em> by calling
    the <em>general algorithm</em> from point 1
    with the special data of the given problem (\( g(t) \), \( a=-2 \), \( b=2 \),
    \( n=1000 \)).</li>
 <li> Before we can believe in the integration of \( g(t) \), we need
    to <em>verify</em> the implementation (see the section <a href="#sec:verify">Verification and testing frameworks</a>).</li>
</ol>

Let us apply the desirable principles 1-3 in a Matlab context.
User-defined Matlab functions must be placed in separate files. This
is sometimes found annoying, and therefore many students and teachers tend to
avoid functions. In the present case, we should implement the
Trapezoidal method in a file <code>Trapezoidal.m</code> containing

<p>

<!-- code=matlab (!bc mpro) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">function</span><span style="color: #bbbbbb"> </span>r =<span style="color: #bbbbbb"> </span><span style="color: #0000FF">Trapezoidal</span>(f, a, b, n)<span style="color: #bbbbbb"></span>
<span style="color: #408080; font-style: italic">% Numerical integration from a to b</span>
<span style="color: #408080; font-style: italic">% with n intervals by the Trapezoidal rule</span>
f = fcnchk(f);
h = (b<span style="color: #666666">-</span>a)<span style="color: #666666">/</span>n;
s = <span style="color: #666666">0.5*</span>(f(a) <span style="color: #666666">+</span> f(b));
<span style="color: #008000; font-weight: bold">for</span> <span style="color: #008000">i</span> = <span style="color: #666666">1</span>:n<span style="color: #666666">-1</span>
    s = s <span style="color: #666666">+</span> f(a<span style="color: #666666">+</span><span style="color: #008000">i</span><span style="color: #666666">*</span>h);
<span style="color: #008000; font-weight: bold">end</span>
r = h<span style="color: #666666">*</span>s;
</pre></div>
<p>
The special \( g(t) \) function can be implemented in a separate file <code>g.m</code>
or put in the main program. The function becomes

<p>

<!-- code=text typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">function v = g(t)
v = exp(-t^4)
end
</pre></div>
<p>
Finally, a specialized main program (<code>main.m</code>) solves the problem at hand:

<p>

<!-- code=text typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">a = -2; b = 2;
n = 1000;
result = Trapezoidal(@g, a, b, n);
disp(result);
exit
</pre></div>
<p>
The important feature of this solution is that <code>Trapezoidal.m</code> can be
reused for &quot;any&quot; integral. In particular, it is straightforward
to also integrate an integrand where we know the exact result.

<p>
An advantage of having the \( g(t) \) as a separate function is that we
can easily send this function to a different integration method, e.g.,
Simpson's rule.

<h2 id="___sec6">Solution 3: Standard Python </h2>

<p>
Both Solution 1 and Solution 2 are readily implemented in Python.
However, functions in Python do <em>not</em> need to be located in separate
files to be reusable, and therefore there is no psychological barrier
to put a piece of code inside a function. The consequence is that a
Python programmer is more likely to go for Solution 2.
(This may be the reason why the author has observed
scientific Python codes to have better design
than Matlab codes - modularization comes more natural.)
The relevant
code can be placed in a single file, say <code>main.py</code>, looking as
follows:

<p>

<!-- code=python (!bc pypro) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">Trapezoidal</span>(f, a, b, n):
    h <span style="color: #666666">=</span> (b<span style="color: #666666">-</span>a)<span style="color: #666666">/</span><span style="color: #008000">float</span>(n)
    s <span style="color: #666666">=</span> <span style="color: #666666">0.5*</span>(f(a) <span style="color: #666666">+</span> f(b))
    <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">0</span>,n,<span style="color: #666666">1</span>):
        s <span style="color: #666666">=</span> s <span style="color: #666666">+</span> f(a <span style="color: #666666">+</span> i<span style="color: #666666">*</span>h)
    <span style="color: #008000; font-weight: bold">return</span> h<span style="color: #666666">*</span>s

<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">math</span> <span style="color: #008000; font-weight: bold">import</span> exp  <span style="color: #408080; font-style: italic"># or from math import *</span>
<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">g</span>(t):
    <span style="color: #008000; font-weight: bold">return</span> exp(<span style="color: #666666">-</span>t<span style="color: #666666">**4</span>)

a <span style="color: #666666">=</span> <span style="color: #666666">-2</span>;  b <span style="color: #666666">=</span> <span style="color: #666666">2</span>
n <span style="color: #666666">=</span> <span style="color: #666666">1000</span>
result <span style="color: #666666">=</span> Trapezoidal(g, a, b, n)
<span style="color: #008000; font-weight: bold">print</span> result
</pre></div>
<p>
This solution acknowledges the fact that the implementation is a
generally applicable function, just as the Trapezoidal formula.

<p>
However, a small adjustment of this implementation will make it
much better. If somebody wants to reuse the <code>Trapezoidal</code> function
for another integral, they can import <code>Trapezoidal</code> from the
<code>main.py</code> file, but the special problem will be executed as part of
the import. This is not desired behavior when solving another problem.
Instead, our special exercise problem should be isolated in
its own function and called from a test block in the file (to avoid
being executed as part of an import).
This is the general software design of <em>modules</em> in Python.

<p>
We therefore rewrite the code in a new file <code>Trapezoidal.py</code>:

<p>

<!-- code=python (!bc pypro) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">Trapezoidal</span>(f, a, b, n):
    h <span style="color: #666666">=</span> (b<span style="color: #666666">-</span>a)<span style="color: #666666">/</span><span style="color: #008000">float</span>(n)
    s <span style="color: #666666">=</span> <span style="color: #666666">0.5*</span>(f(a) <span style="color: #666666">+</span> f(b))
    <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">1</span>,n,<span style="color: #666666">1</span>):
        s <span style="color: #666666">=</span> s <span style="color: #666666">+</span> f(a <span style="color: #666666">+</span> i<span style="color: #666666">*</span>h)
    <span style="color: #008000; font-weight: bold">return</span> h<span style="color: #666666">*</span>s

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">_my_special_problem</span>():
    <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">math</span> <span style="color: #008000; font-weight: bold">import</span> exp
    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">g</span>(t):
        <span style="color: #008000; font-weight: bold">return</span> exp(<span style="color: #666666">-</span>t<span style="color: #666666">**4</span>)

    a <span style="color: #666666">=</span> <span style="color: #666666">-2</span>;  b <span style="color: #666666">=</span> <span style="color: #666666">2</span>
    n <span style="color: #666666">=</span> <span style="color: #666666">1000</span>
    result <span style="color: #666666">=</span> Trapezoidal(g, a, b, n)
    <span style="color: #008000; font-weight: bold">print</span> result

<span style="color: #008000; font-weight: bold">if</span> __name__ <span style="color: #666666">==</span> <span style="color: #BA2121">&#39;__main__&#39;</span>:
    _my_special_problem()
</pre></div>
<p>
Now we have obtained the following important features:

<ul>
 <li> The file <code>Trapezoidal.py</code> is a module offering the widely applicable
   function <code>Trapezoidal</code> for integrating &quot;any&quot; function.</li>
 <li> If <code>Trapezoidal.py</code> is run as a program, the if test is true and
   the special integral of \( g \) is computed.</li>
 <li> In an import like <code>from Trapezoidal import Trapezoidal</code>, the if test
   is false and nothing gets computed.</li>
</ul>

<h1 id="sec:verify">Verification and testing frameworks</h1>

<p>
An integral part of any implementation is verification, i.e., to bring
evidence that the program works correctly from a mathematical point of view.
(A related term, validation, refers to bringing evidence that the program
produces results in accordance with observations of nature, but this is
not of direct interest in this integration context.)

<p>
The intuitive approach to testing is to compare results of a program
with known mathematical results. For example, we can choose some
function, say \( \sin t \), and differentiate it to obtain an integrand
that we can easily integrate by hand and thereby get a precise number
for the integral.  Integrating \( \int_{-2}^2 \cos t\,dt \) gives the
exact result 1.81859485365.  The program with the Trapezoidal rule
reports 1.81859242886, so the error \( 2.42\cdot 10^{-6} \) is &quot;small&quot;.
However, we have no idea if this error is just the approximation error in
the numerical method or if the program has a bug too! What if the
error were \( 1.67\cdot 10^{-3} \)? It is impossible to say whether this
answer is the correct numerical result or not.  Actually, this error
contains both the approximation error and a bug where the loop goes
over \( 0,1,\ldots,n-1 \).

<p>
So, comparison of a numerical approximation with an exact answer does
not say much unless the error is &quot;huge&quot; and therefore clearly points
to fundamental bugs in the code.

<p>
For most numerical methods there are only two good verification methods:

<ol>
<li> Computation of a problem where the approximation error vanishes.</li>
<li> Empirical measurement of the convergence rate.</li>
</ol>

Verification methods should be implemented in <em>test functions</em> that
can be run at any time to check if the implementation is correct.

<h2 id="___sec8">A simple test function </h2>

<p>
The Trapezoidal rule is obviously exact for linear integrands. Therefore,
we should test an &quot;arbitrary&quot; linear function and check that the
error is close to machine precision. This is done in a separate
function in a separate file <a href="https://github.com/hplgit/hplgit.github.com/tree/master/edu/py_vs_m/src/test_Trapezoidal.py" target="_self"><tt>test_Trapezoidal.py</tt></a>:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">Trapezoidal</span> <span style="color: #008000; font-weight: bold">import</span> Trapezoidal
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">Trapezoidal_vec</span> <span style="color: #008000; font-weight: bold">import</span> Trapezoidal <span style="color: #008000; font-weight: bold">as</span> Trapezoidal_vec

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">linear</span>():
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Test linear integrand: exact result for any n.&quot;&quot;&quot;</span>

    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">f</span>(x):
        <span style="color: #008000; font-weight: bold">return</span> <span style="color: #666666">8*</span>x <span style="color: #666666">+</span> <span style="color: #666666">6</span>

    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">F</span>(x):
        <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Anti-derivative of f(x).&quot;&quot;&quot;</span>
        <span style="color: #008000; font-weight: bold">return</span> <span style="color: #666666">4*</span>x<span style="color: #666666">**2</span> <span style="color: #666666">+</span> <span style="color: #666666">6*</span>x

    a <span style="color: #666666">=</span> <span style="color: #666666">2</span>
    b <span style="color: #666666">=</span> <span style="color: #666666">6</span>
    exact <span style="color: #666666">=</span> F(b) <span style="color: #666666">-</span> F(a)
    numerical <span style="color: #666666">=</span> Trapezoidal(f, a, b, n<span style="color: #666666">=4</span>)
    error <span style="color: #666666">=</span> exact <span style="color: #666666">-</span> numerical
    <span style="color: #008000; font-weight: bold">print</span> <span style="color: #BA2121">&#39;</span><span style="color: #BB6688; font-weight: bold">%.16f</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> error
</pre></div>
<p>
The output of calling <code>linear()</code>
is in this case zero exactly, but in general one must expect
some small rounding errors in the numerical and exact result.

<h2 id="___sec9">A proper test function for the nose or pytest test framework </h2>

<p>
The function <code>linear</code> performs the test, but it would be better to
integrate the test into a <em>testing framework</em> such that we with
one command can execute a comprehensive set of tests. This makes it
easy to run all tests after every small change of the software.
Students should adopt such compulsory habits from the software industry.

<p>
The dominating type of test frameworks today is based on what is called
<em>unit testing</em> in software engineering. It means that we pick a unit
in the software and write a function (or class) that runs the test
after certain specifications:

<ul>
 <li> The test function must start with <code>test_</code>.</li>
 <li> The test function cannot have any arguments.</li>
 <li> If the test fails, an <code>AssertionError</code> exception (in Python) is raised, otherwise the function runs silently.</li>
</ul>

There are two very popular test frameworks in the Python world now:
pytest and nose. There are similar frameworks developed for Matlab too,
see <a href="http://se.mathworks.com/support/2015a/matlab/8.5/demos/matlab-unit-test-framework-in-release-2013a.html" target="_self">a video</a>,
but they are not as user friendly since they require the programmer
to embed tests in classes (this is still the dominating method in
most programming languages).
Using test functions instead of test classes requires
writing less code and is easier to learn.

<p>
In our case, a proper test function means the following rewrite
of the function <code>linear</code>:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_linear</span>():
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Test linear integrand: exact result for any n.&quot;&quot;&quot;</span>

    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">f</span>(x):
        <span style="color: #008000; font-weight: bold">return</span> <span style="color: #666666">8*</span>x <span style="color: #666666">+</span> <span style="color: #666666">6</span>

    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">F</span>(x):
        <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Anti-derivative of f(x).&quot;&quot;&quot;</span>
        <span style="color: #008000; font-weight: bold">return</span> <span style="color: #666666">4*</span>x<span style="color: #666666">**2</span> <span style="color: #666666">+</span> <span style="color: #666666">6*</span>x

    a <span style="color: #666666">=</span> <span style="color: #666666">2</span>
    b <span style="color: #666666">=</span> <span style="color: #666666">6</span>
    expected <span style="color: #666666">=</span> F(b) <span style="color: #666666">-</span> F(a)
    tol <span style="color: #666666">=</span> <span style="color: #666666">1E-14</span>
    computed <span style="color: #666666">=</span> Trapezoidal(f, a, b, n<span style="color: #666666">=4</span>)
    error <span style="color: #666666">=</span> <span style="color: #008000">abs</span>(expected <span style="color: #666666">-</span> computed)
    msg <span style="color: #666666">=</span> <span style="color: #BA2121">&#39;Trapezoidal: expected=</span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BA2121">, computed=</span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BA2121">, error=</span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> \ 
          (expected, computed, error)
    <span style="color: #008000; font-weight: bold">assert</span> error <span style="color: #666666">&lt;</span> tol, msg
</pre></div>
<p>
The code is basically the same, but we comply to the rules in the three
bullet points above. The <code>assert</code>
statement has the test as <code>error &lt; tol</code>, with <code>msg</code> as an optional
message that is printed only if the test fails (<code>error &lt; tol</code> is <code>False</code>).
The <code>msg</code> string can be left out and it suffices to do <code>assert error &lt; tol</code>.

<p>
The reason why we comply to testing frameworks is that we can use software
like nose or pytest to automatically find all our tests and execute them.
We put tests in files or directories starting with <code>test</code> and run
one of the commands

<p>

<!-- code=text (!bc sys) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">Terminal&gt; nosetests -s -v .
Terminal&gt; py.test -s -v .
</pre></div>
<p>
All functions with names <code>test_*()</code> in all files <code>test*.py</code> in all
subdirectories with names <code>test*</code> will
be run, and statistics about how many tests that failed will be printed.
The tests should be run after every modification of the software.

<h2 id="___sec10">Use of symbolic computing for exact results </h2>

<p>
We integrated by hand the linear function used in the test above.
In more complicated cases it
would be safer to use symbolic computing software to carry out the
mathematics. Here we demonstrate how to
use the Python package SymPy to do the integration:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_linear_symbolic</span>():
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Test linear integrand: exact result for any n.&quot;&quot;&quot;</span>
    <span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">sympy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">sym</span>
    <span style="color: #408080; font-style: italic"># Define a linear expression and integrate it</span>
    x <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>symbols(<span style="color: #BA2121">&#39;x&#39;</span>)
    f <span style="color: #666666">=</span> <span style="color: #666666">8*</span>x <span style="color: #666666">+</span> <span style="color: #666666">6</span>                 <span style="color: #408080; font-style: italic"># Integrand for this test</span>
    F <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>integrate(f, x)
    <span style="color: #408080; font-style: italic"># Verify symbolic computation: F&#39;(x) == f(x)</span>
    <span style="color: #008000; font-weight: bold">assert</span> sym<span style="color: #666666">.</span>diff(F, x) <span style="color: #666666">==</span> f
    <span style="color: #408080; font-style: italic"># Transform expressions f and F to Python functions of x</span>
    f <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>lambdify([x], f, modules<span style="color: #666666">=</span><span style="color: #BA2121">&#39;numpy&#39;</span>)
    F <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>lambdify([x], F, modules<span style="color: #666666">=</span><span style="color: #BA2121">&#39;numpy&#39;</span>)

    <span style="color: #408080; font-style: italic"># Run one test with fixed a, b, n, for scalar and</span>
    <span style="color: #408080; font-style: italic"># vectorized implementation</span>
    a <span style="color: #666666">=</span> <span style="color: #666666">2</span>
    b <span style="color: #666666">=</span> <span style="color: #666666">6</span>
    expected <span style="color: #666666">=</span> F(b) <span style="color: #666666">-</span> F(a)
    tol <span style="color: #666666">=</span> <span style="color: #666666">1E-14</span>
    <span style="color: #008000; font-weight: bold">for</span> func <span style="color: #AA22FF; font-weight: bold">in</span> Trapezoidal, Trapezoidal_vec:
        computed <span style="color: #666666">=</span> func(f, a, b, n<span style="color: #666666">=4</span>)
        error <span style="color: #666666">=</span> <span style="color: #008000">abs</span>(expected <span style="color: #666666">-</span> computed)
        msg <span style="color: #666666">=</span> <span style="color: #BA2121">&#39;expected=</span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BA2121">, computed=</span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BA2121">, error=</span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> \ 
              (expected, computed, error)
        <span style="color: #008000; font-weight: bold">assert</span> error <span style="color: #666666">&lt;</span> tol, msg
</pre></div>
<p>
Note that we now also test both the scalar and the vectorized implementations
of the Trapezoidal rule (see the section <a href="#sec:HPC:vec">High-performance computing: vectorization</a> for explanation of the
vectorized version <code>Trapezoidal_vec</code>).
It is easy in Python to loop over functions (with a variable like <code>func</code>).
We could also just compare the result of <code>Trapezoidal_vec</code> to that of
<code>Trapezoidal</code> when the latter is verified against the <code>expected</code> value.

<h2 id="___sec11">Use relative errors </h2>

<p>
Let us change the integration limits in our test example to
\( a=2\cdot 10^8 \) and \( b=6\cdot 10^9 \).
The computed error in this case is 16384 (!). Hence the tolerance
must be set to (e.g.) \( 2\cdot 10^5 \) (!). In general, the tolerance
depends on the magnitude of the numbers involved in the computations.
To avoid this dependence, one should use <em>relative errors</em>:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">error <span style="color: #666666">=</span> <span style="color: #008000">abs</span>(expected <span style="color: #666666">-</span> computed)<span style="color: #666666">/</span><span style="color: #008000">abs</span>(expected)
</pre></div>
<p>
Now, a tolerance of \( 10^{-14} \) is adequate for the test even if
the numbers <code>expected</code> and <code>computed</code> are large.

<p>
A function <code>test_linear_symbolic_large_limits</code> in the
file <code>test_Trapezoidal.py</code> is a test function for a case with large limits
and use of the relative error.

<h2 id="___sec12">Test function for the convergence rate </h2>

<p>
Let us extend the verification with a case where we know the exact answer
of the integral, but we do not know the approximation error.
The only knowledge we usually have about the approximation error is
of asymptotic type. For example, for the Trapezoidal rule we have an
expression for the error from numerical analysis:

$$ E = - \frac{(b-a)^3}{12n^2}f''(\xi),\quad\xi\in [a,b]. $$

Since we do not know \( \xi \), which is some number in \( [a,b] \),
we cannot compute \( E \).
However, we realize that the error has an asymptotic behavior as
\( n^{-2} \):

$$ E = Cn^{-2}, $$

for some unknown constant \( C \). If we compute two or more errors for
different \( n \) values, we can
check that the error decays as \( n^{-2} \).
In general, when verifying the implementation
of a numerical
method with discretization parameter \( n \), we write \( E=Cn^r \), estimate
\( r \), and compare with the exact result (here \( n=-2 \)).

<p>
More precisely, we perform a set of experiments for \( n=n_0, n_1,
\ldots, n_m \), where we empirically estimate \( r \) from
two consecutive experiments:

$$
\begin{align*}
E_i &= Cn_i^r,\\ 
E_{i+1} &= Cn_{i+1}^r.
\end{align*}
$$

Dividing the equations and solving with respect to \( r \) gives

$$ r = \frac{\ln(E_i/E_{i+1})}{\ln(r_i/r_{i+1})}$$

As \( i=0,\ldots,m-1 \), the \( r \) values should approach the value \( -2 \).

<p>
It is easy to use the <em>method of manufactured solutions</em> to construct a
test problem. That is, we first choose the solution, say the integral
is given by \( F(b)-F(a) \), where

$$ F(x) = e^{-x}\sin (2x).$$

Then we fit the problem to accept this solution. In the present case
it means that the integrand must be \( f(x)=F'(x) \). We use for safety symbolic
software to calculate \( f(x) \). Thereafter, we run a series of experiments
where \( n \) is varied, we compute the corresponding convergence rates \( r \)
from two consecutive experiments and test if the final \( r \), corresponding
to the two largest \( n \) values, is sufficiently close to the expected
convergence rate \( -2 \):

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_convergence_rate</span>():
    <span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">sympy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">sym</span>
    <span style="color: #408080; font-style: italic"># Construct test problem</span>
    x <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>symbols(<span style="color: #BA2121">&#39;x&#39;</span>)
    F <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>exp(<span style="color: #666666">-</span>x)<span style="color: #666666">*</span>sym<span style="color: #666666">.</span>sin(<span style="color: #666666">2*</span>x)  <span style="color: #408080; font-style: italic"># Anti-derivative</span>
    f <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>diff(F, x)            <span style="color: #408080; font-style: italic"># Integrand for this test</span>
    <span style="color: #408080; font-style: italic"># Turn to Python functions</span>
    f <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>lambdify([x], f, modules<span style="color: #666666">=</span><span style="color: #BA2121">&#39;numpy&#39;</span>)
    F <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>lambdify([x], F, modules<span style="color: #666666">=</span><span style="color: #BA2121">&#39;numpy&#39;</span>)

    a <span style="color: #666666">=</span> <span style="color: #666666">0.1</span>
    b <span style="color: #666666">=</span> <span style="color: #666666">0.9</span>
    expected <span style="color: #666666">=</span> F(b) <span style="color: #666666">-</span> F(a)
    <span style="color: #408080; font-style: italic"># Run experiments (double n in each experiment)</span>
    n <span style="color: #666666">=</span> <span style="color: #666666">1</span>
    errors <span style="color: #666666">=</span> []
    <span style="color: #008000; font-weight: bold">for</span> k <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">28</span>):
        n <span style="color: #666666">*=</span> <span style="color: #666666">2</span>
        computed <span style="color: #666666">=</span> Trapezoidal(f, a, b, n)
        error <span style="color: #666666">=</span> <span style="color: #008000">abs</span>(expected <span style="color: #666666">-</span> computed)
        errors<span style="color: #666666">.</span>append((n, error))
        <span style="color: #008000; font-weight: bold">print</span> k, n, error
    <span style="color: #408080; font-style: italic"># Compute empirical convergence rates</span>
    <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">math</span> <span style="color: #008000; font-weight: bold">import</span> log <span style="color: #008000; font-weight: bold">as</span> ln
    estimator <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">lambda</span> E1, E2, n1, n2: ln(E1<span style="color: #666666">/</span>E2)<span style="color: #666666">/</span>ln(<span style="color: #008000">float</span>(n1)<span style="color: #666666">/</span>n2)
    r <span style="color: #666666">=</span> []
    <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #008000">len</span>(errors)<span style="color: #666666">-1</span>):
        n1, E1 <span style="color: #666666">=</span> errors[i]
        n2, E2 <span style="color: #666666">=</span> errors[i<span style="color: #666666">+1</span>]
        r<span style="color: #666666">.</span>append(estimator(E1, E2, n1, n2))
    expected <span style="color: #666666">=</span> <span style="color: #666666">-2</span>
    computed <span style="color: #666666">=</span> r[<span style="color: #666666">-1</span>]  <span style="color: #408080; font-style: italic"># The &quot;most&quot; asymptotic value</span>
    error <span style="color: #666666">=</span> <span style="color: #008000">abs</span>(expected <span style="color: #666666">-</span> computed)
    tol <span style="color: #666666">=</span> <span style="color: #666666">1E-3</span>
    msg <span style="color: #666666">=</span> <span style="color: #BA2121">&#39;Convergence rates: </span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> r
    <span style="color: #008000; font-weight: bold">print</span> errors
    <span style="color: #008000; font-weight: bold">assert</span> error <span style="color: #666666">&lt;</span> tol, msg
</pre></div>
<p>
The empirical convergence rates are in this example

<p>

<!-- code=text typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">-2.022, -2.0056, -2.0014, -2.00035, -2.000086, -2.000022,
-2.0000054, -2.0000013, -2.00000033
</pre></div>
<p>
Although the rates are known to approach \( -2 \) as \( n\rightarrow\infty \),
the rates are close to \( -2 \) even for large \( n \) (such as \( n=4 \)).
A rough tolerance is often used for convergence rates, for instance 0.1,
but here we may use a smaller one if desired.

<p>
<div class="alert alert-block alert-warning alert-text-normal"><b>Summary.</b>
Knowing an exact solution to a mathematical problem
and comparing the program output with such a solution,
gives only an indication that the program may be
correct, but it is only a rough indication.
Any real test must use what we know about the approximation error,
and that is usually only an asymptotic behavior as function of discretization
parameters. The test needs to vary the discretization parameter(s)
to estimate convergence rates for comparison with known asymptotic results.

<p>
Known analytical solutions are of value in convergence rate tests, but
if they are not available, or restricted to very simplified cases,
the method of manufactured solutions, where we solve a perturbed problem
fitted to a constructed exact solution, is also a very useful technique.
</div>


<h2 id="___sec13">Tests in Matlab </h2>

<p>
In Matlab, one must decide whether to use a class-based system for unit
testing or just write test functions that mimic the behavior of the
Python test functions for the nose and pytest frameworks. Here is an
example on doing the <code>test_linear()</code> function in Matlab:

<p>

<!-- code=matlab (!bc mpro) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">function</span> <span style="color: #0000FF">test_trapezoidal_linear</span>
 <span style="color: #408080; font-style: italic">%% Check that linear functions are integrated exactly</span>
  f = @(x) <span style="color: #666666">8*</span>x <span style="color: #666666">+</span> <span style="color: #666666">6</span>;
  F = @(x) <span style="color: #666666">4*</span>x<span style="color: #666666">**2</span> <span style="color: #666666">+</span> <span style="color: #666666">6*</span>x;  <span style="color: #408080; font-style: italic">%% Anti-derivative</span>
  a = <span style="color: #666666">2</span>;
  b = <span style="color: #666666">6</span>;
  expected = F(b) <span style="color: #666666">-</span> F(a);
  tol = <span style="color: #666666">1E-14</span>;
  computed = trapezoidal(f, a, b, <span style="color: #666666">4</span>);
  error = <span style="color: #008000">abs</span>(expected <span style="color: #666666">-</span> computed);
  assert(error <span style="color: #666666">&lt;</span> tol, <span style="color: #BA2121">&#39;n=%d, error=%g&#39;</span>, n, error);
  <span style="color: #008000; font-weight: bold">end</span>
<span style="color: #008000; font-weight: bold">end</span>

test_trapezoidal_linear()
</pre></div>
<p>
There is, unfortunately, no software available to run all tests in all
files in all subdirectories and report on the success/failure statistics,
but it is quite straightforward to write such software.

<h2 id="___sec14">Rounding errors </h2>

<p>
Verification in terms of measuring convergence rates usually gives a
very good insight into approximation errors, but the verification
results may be affected by rounding errors, depending on the type
of algorithm. For the scalar implementation of the Trapezoidal rule,
rounding errors start to affect the results around \( n=2^{24}\approx 16 \)
million points. Other algorithms are much more sensitive to rounding
errors. For example, a numerical derivative like

$$ f''(x)\approx \frac{f(x+h)-2f(x) + f(x+h)}{h^2},$$

may be subject to rounding errors for moderate values of \( h \).
Here is an example with \( f(x)=x^{-6} \). An exact answer is \( f''(1)=42 \),
but numerical experiments for with \( h=10^{-k} \) for various \( k \)
values end up with

<p>

<div class="row">
  <div class="col-xs-3">
    <table class="table table-striped table-hover table-condensed">
<thead>
<tr><td align="center">\( k \)</td> <td align="center">numerical \( f'' \)</td> </tr>
</thead>
<tbody>
<tr><td align="right">   1          </td> <td align="right">   44.61504               </td> </tr>
<tr><td align="right">   2          </td> <td align="right">   42.02521               </td> </tr>
<tr><td align="right">   3          </td> <td align="right">   42.00025               </td> </tr>
<tr><td align="right">   4          </td> <td align="right">   42.00000               </td> </tr>
<tr><td align="right">   5          </td> <td align="right">   41.99999               </td> </tr>
<tr><td align="right">   6          </td> <td align="right">   42.00074               </td> </tr>
<tr><td align="right">   7          </td> <td align="right">   41.94423               </td> </tr>
<tr><td align="right">   8          </td> <td align="right">   47.73959               </td> </tr>
<tr><td align="right">   9          </td> <td align="right">   -666.13381             </td> </tr>
<tr><td align="right">   10         </td> <td align="right">   0.00000                </td> </tr>
<tr><td align="right">   11         </td> <td align="right">   0.00000                </td> </tr>
<tr><td align="right">   12         </td> <td align="right">   -666133814.8           </td> </tr>
<tr><td align="right">   13         </td> <td align="right">   66613381477.5          </td> </tr>
<tr><td align="right">   14         </td> <td align="right">   0.00000                </td> </tr>
</tbody>
    </table>
  </div> <!-- col-xs-3 -->
</div> <!-- cell row -->
<p>
The error starts to increase rather than decrease for \( h>10^{-5} \), and
this is because the rounding error is (much) bigger than the approximation
error in the formula.

<h1 id="___sec15">Incorporation of other learning outcomes </h1>

<p>
We discuss here how some of the learning outcomes from the section <a href="._computing_competence003.html#sec:learning_outcomes">General learning outcomes for computing competence</a> can be incorporated in the exercise with
the Trapezoidal rule. We restrict programming examples to use Python.

<h2 id="sec:HPC:vec">High-performance computing: vectorization</h2>

<p>
This author has seen a lot of programs used for teaching which apply
vectorization without explicit notice. Vectorization is a technique
in high-level languages like IDL, MATLAB, Python, and R for
removing loops and speed up computations. Unfortunately, the &quot;distance&quot;
from the mathematical algorithm to vectorized code is larger than
to a plain loop as we used above. Vectorization therefore tends to confuse
students who are not well educated in the techniques.
For example, the Trapezoidal rule can be vectorized as

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">np</span>

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">Trapezoidal</span>(f, a, b, n):
    x <span style="color: #666666">=</span> np<span style="color: #666666">.</span>linspace(a, b, n<span style="color: #666666">+1</span>)
    <span style="color: #008000; font-weight: bold">return</span> (b<span style="color: #666666">-</span>a)<span style="color: #666666">/</span><span style="color: #008000">float</span>(n)<span style="color: #666666">*</span>(np<span style="color: #666666">.</span>sum(f(x)) <span style="color: #666666">-</span> <span style="color: #666666">0.5*</span>(f(a) <span style="color: #666666">+</span> f(b)))
</pre></div>
<p>
The code is correct, but it takes some thinking to realize why these
lines compute the formula <a href="#mjx-eqn-1">(1)</a>. Because of the <code>sum</code> function,
we need to adjust the summation result such that
the weight of the end points becomes correct.

<p>
<div class="alert alert-block alert-success alert-text-normal"><b>Tip: Implement scalar code first - then vectorize.</b>
It is much easier to get a scalar code, with explicit loops that
mimic the mathematical formula(s) as closely as possible, to work first.
Then remove loops by vectorized expressions and test the code
against the scalar version.
</div>


<h2 id="___sec17">High-performance computing: memory usage </h2>

<p>
The scalar implementation of the Trapezoidal rule computes one <code>f(x)</code>
at the time and uses very little memory, actually only 4 <code>float</code>
variables. The vectorized version, however, computes the
function values at all points <code>x</code> (\( n+1 \) <code>float</code> objects)
at once and therefore requires the storage of about \( n \) <code>float</code> objects.
This is a significant difference between the vectorized and scalar
versions. The vectorized version may run out of memory if we
want very accurate results and hence a large \( n \).

<h2 id="___sec18">High-performance computing: parallelization </h2>

<p>
An important observation for parallelization of the Trapezoidal
rule is that all the function evaluations are independent of each
other so these can be performed in parallel. Typically, with \( m \)
compute units we can distribute <code>int(n/m)</code> function evaluations
to the first \( m-1 \) units and <code>int(n/m) + n % m</code> to the last one.
Each unit must compute the sum of the evaluations and
communicate to one master unit or to all other units.
The master or all units must then sum up all the partial sums,
subtract \( \frac{1}{2}(f(a) + f(b)) \) and multiply by \( h \) to get the
final answer.

<p>
Vectorized algorithms often lend themselves to automatic parallelization.
In fact, the <a href="http://numba.pydata.org" target="_self">Numba</a> tool can automatically
parallelize Numerical Python code. Looking at the vectorized
Trapezoidal implementation

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">x <span style="color: #666666">=</span> np<span style="color: #666666">.</span>linspace(a, b, n<span style="color: #666666">+1</span>)
I <span style="color: #666666">=</span> (b<span style="color: #666666">-</span>a)<span style="color: #666666">/</span><span style="color: #008000">float</span>(n)<span style="color: #666666">*</span>(np<span style="color: #666666">.</span>sum(f(x)) <span style="color: #666666">-</span> <span style="color: #666666">0.5*</span>(f(a) <span style="color: #666666">+</span> f(b)))
</pre></div>
<p>
and assuming that <code>n</code> is large, we realize that <code>np.linspace</code> must
create the vector on \( m \) compute units, each with its own memory.
In the next expression, <code>f(x)</code> leads to application of <code>f</code> on the
piece of <code>x</code> that is on each compute unit. Then <code>np.sum</code> creates
partial sums of <code>f(x)</code> on each compute unit and distributes the
results to all other units. No more (distributed) vectors are involved,
so the remaining scalar operations can be carried out on every unit,
and the final result of the integral is then available on each individual
compute unit.

<p>
We think it is fundamental that such reasoning is well known among
students. Traditionally, thinking about parallelism has not been in focus
unless also demanding technical implementations in terms of MPI is
also taught. However, laptops will soon be powerful parallel
computing platforms, so knowing how to write code that lend itself to
easy parallelization by tools such as NumPy and Numba is key.
How parallel code is actually implemented may be pushed to a more specialized
courses.

<h2 id="___sec19">Understanding of approximation errors </h2>

<p>
Since the asymptotic behavior of approximation errors is so fundamental
for the most common verification technique (i.e., checking convergence
rates), students should be well motivated for diving more into
the mathematics behind the various formulas they use in test functions.

<p>

<iframe width="640" height="365" src="https://www.youtube.com/embed/ln1L0xbEM3s" frameborder="0" allowfullscreen></iframe>

<h2 id="___sec20">Overview of advanced algorithms </h2>

<p>
The Trapezoidal rule is primarily a pedagogical tool for obtaining a
good understanding numerical integration and what integration is.
For professional use, one will apply more sophisticated algorithms,
for instance algorithms that deliver an estimate of the integral with
a specified error tolerance.

<p>
In the scientific Python eco system we have the <code>quad</code> method
for sophisticated integration, from
the famous QUADPACK Fortran library and made available in the SciPy package.
Here we integrate \( \int_{-2}^2\cos t\,dt \) with a relative error
tolerance of \( 10^{-12} \):

<p>

<!-- code=python (!bc pyshell) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">scipy.integrate</span>
<span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">math</span> <span style="color: #008000; font-weight: bold">import</span> cos
<span style="color: #666666">&gt;&gt;&gt;</span> I, error <span style="color: #666666">=</span> scipy<span style="color: #666666">.</span>integrate<span style="color: #666666">.</span>quad(cos, <span style="color: #666666">-2</span>, <span style="color: #666666">2</span>, epsrel<span style="color: #666666">=1E-12</span>)
<span style="color: #666666">&gt;&gt;&gt;</span> I
<span style="color: #666666">1.8185948536513632</span>
<span style="color: #666666">&gt;&gt;&gt;</span> error
<span style="color: #666666">2.4124935390890847e-14</span>
</pre></div>

<h2 id="___sec21">Uncertainty quantification </h2>

<p>
We want to compute \( I=\int_a^{2}\cos t\,dt \), but \( a \) is an uncertain
parameter. Suppose \( a \) can be modeled as a normally distributed
stochastic variable with mean -2 and standard deviation 0.2.
What is the corresponding uncertainty in \( I \)? The simplest statistics
reflecting the uncertainty of \( I \) is the mean and the standard deviation.
Monte Carlo simulation is the simplest method for computing the uncertainty.

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">Trapezoidal_vec</span> <span style="color: #008000; font-weight: bold">import</span> Trapezoidal
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">np</span>
N <span style="color: #666666">=</span> <span style="color: #666666">100000</span>       <span style="color: #408080; font-style: italic"># Monte Carlo samples</span>
a <span style="color: #666666">=</span> np<span style="color: #666666">.</span>random<span style="color: #666666">.</span>normal(loc<span style="color: #666666">=-2</span>, scale<span style="color: #666666">=0.2</span>, size<span style="color: #666666">=</span>N)  <span style="color: #408080; font-style: italic"># N samples of a</span>
I <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros(N)  <span style="color: #408080; font-style: italic"># Responses (integrals)</span>
<span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(N):
    I[i] <span style="color: #666666">=</span> Trapezoidal(np<span style="color: #666666">.</span>cos, a[i], <span style="color: #666666">2</span>, n<span style="color: #666666">=1000</span>)
<span style="color: #008000; font-weight: bold">print</span> <span style="color: #BA2121">&#39;Integral of cos(t) from t=-2 to t=2:&#39;</span>, np<span style="color: #666666">.</span>sin(<span style="color: #666666">2</span>) <span style="color: #666666">-</span> np<span style="color: #666666">.</span>sin(<span style="color: #666666">-2</span>)
<span style="color: #008000; font-weight: bold">print</span> <span style="color: #BA2121">&#39;Mean value of uncertain integral:&#39;</span>, np<span style="color: #666666">.</span>mean(I)
<span style="color: #008000; font-weight: bold">print</span> <span style="color: #BA2121">&#39;Standard deviation of uncertain integral:&#39;</span>, np<span style="color: #666666">.</span>std(I)
</pre></div>
<p>
The output becomes

<p>

<!-- code=text typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">Integral of cos(t) from t=-2 to t=2: 1.81859485365
Mean value of uncertain integral: 1.80044133926
Standard deviation of uncertain integral: 0.0856614641125
</pre></div>
<p>
<p>
<!-- navigation buttons at the bottom of the page -->
<ul class="pager">
  <li class="previous">
    <a href="._computing_competence003.html">&larr; Prev</a>
  </li>
  <li class="next">
    <a href="._computing_competence005.html">Next &rarr;</a>
  </li>
</ul>
<!-- ------------------- end of main content --------------- -->

</div>  <!-- end container -->
<!-- include javascript, jQuery *first* -->
<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script>
<script src="http://netdna.bootstrapcdn.com/bootstrap/3.0.0/js/bootstrap.min.js"></script>

<!-- Bootstrap footer
<footer>
<a href="http://..."><img width="250" align=right src="http://..."></a>
</footer>
-->


</body>
</html>
    

